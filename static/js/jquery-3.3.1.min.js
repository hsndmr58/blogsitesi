/ *! jQuery v3.3.1 | (c) JS Vakfı ve diğer katılımcılar | jquery.org/license * /
! function (e, t) {"kullanımı katı"; "nesne" == modül modülü && "nesne" == typeof module.exports? module.exports = e.document? t (e,! 0): function (e) {if (! e.document) yeni bir hata atar ("jQuery, bir belgeye sahip bir pencere gerektirir"); t (e)} döndürür: t (e)} ("tanımsız"! = pencereye yazılır mı? pencere: bu, işlev ( e, t) {"kullanımı katı"; var n = [], r = e.document, i = Object.getPrototypeOf, o = n.slice, a = n.concat, s = n.push, u = n. indexOf, l = {}, c = l.toString, f = l.hasOwnProperty, p = f.toString, d = p.call (Nesne), h = {}, g = işlevi e (t) {return "işlevi "== t &&" numarası "! = = t.nodeType}, t = işlevi e (t) {= null döndürün! = t && t === t.window}, v = {type:! 0, src:! 0, noModule:! 0}; işlev m (e, t, n) {var i, o = (t = t || r) .createElement ("script"); eğer (o.text = e, n) (i) için v) n [i] && (o [i] = n [i]); t.head.appendChild (o) .parentNode.removeChild (o)} işlevi x (e) {return null == e? e + "": "nesne" == typeof e || "function" == typeof e? l [c.call (e)] || " nesne ": e = vareof b}" 3.3.1 ", w = fonksiyon (e, t) {yeni w.fn.init (e, t)}, T = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; w.fn = w.prototype = {jquery: "3.3.1", yapıcı: w, uzunluk: 0, toArray: function () {return o.call (this)}, get: function (e) {return null == e? o.call (this): e <0? this [e + this.length]: this [e]}, pushStack: function (e) {var t = w.merge (this.constructor (), e); return t.prevObject = this, t}, her biri: function (e) {return w.each (this, e)}, harita: function (e ) {this.pushStack döndürün (w.map (this, function (t, n) {return e.call (t, n, t)}))}, dilim: function () {return this.pushStack (o.apply) (this, argümanlar))}, first: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (e) {var t = this .length, n = + e + (e <0 t: 0);this.pushStack (n> = 0 && n <t? [this [n]]: [])}, end: function () {return this.prevObject || this.constructor ()}, bas: s, sıralama: n .sort, splice: n.splice}, w.extend = w.fn.extend = function () {varis, t, n, r, i, o, a = argümanlar [0] || {}, s = 1, u = arguments.length, l =! 1; (("boolean" == typeof a && (l = a, a = arguments [s] || {}, s ++), "object" == typeof a || gr (a) '|| (a = {}), === u && (a = bu, s - s) s <u s ++) halinde (! boş = (e = argümanlar [s])) için ( t e) n = a [t], a! == (r = e [t]) && (l && r && (w.isPlainObject (r) || (i = Array.isArray (r)))) (i? (i = 1, o = n && Array.isArray (n), n:!? []): o = n && w.isPlainObject (n) terimi n: {}, a [t] = w.extend (l, l o, r) ): void 0! == r && (a [t] = r)); bir} döndür, w.extend ({expando: "jQuery" + ("3.3.1" + Math.random ()).) (/ \ D / g, ""), isReady:! 0, error: function (e) {yeni hata at (e)}, noop: function () {},isPlainObject: function (e) {var t, n; return! (! e || "[object Object]"! == c.call (e)) && (! (t = i (e)) || "function "== typeof (n = f.call (t," constructor ") && t.constructor) && p.call (n) === d)}, isEmptyObject: function (e) {var t; için (e in t) return! 1; return! 0}, globalEval: function (e) {m (e)}, her biri: function (e, t) {var n, r = 0; eğer (C (e)) {için (n = e.length; r <n; r ++) eğer (! 1 === t.call (e [r], r, e [r])) koparmak için başka (r in e) eğer (! 1 === t.call (e [r], r, e [r])) break; e} dönüş, trim: function (e) {return null == e? "" :( e + ""). (T, " ")}, makeArray: function (e, t) {var n = t || []; return null! = e && (C (Nesne (e))? w.merge (n," string "== typeof e? [e]: e): s.call (n, e)), n}, inArray: function (e, t, n) {return null == t? -1: u.call (t, e, n) }, birleştirme: işlev (e, t) {için (var n = + t. uzunluk, r = 0, i = e.length; r <n; r ++) e [i ++] = t [r]; dönüş e. uzunluğu = ı, e}, grep:işlevi (e, t, n) {için (var r, i = [], o = 0, a = e.length, s =! n; o <a; o ++) (r =! t (e [o] , o))! == s && i.push (e [o]); i} döndür, harita: işlevi (e, t, n) {var r, i, o = 0, s = []; eğer (C ( e)) (r = e.ongth; o <r; o ++) null! = (i = t (e [o], o, n)) && s.push (i); ! = (i = t (e [o], o, n)) && s.push (i); a.apply ([], s)} döndürün, guid: 1, destek: h}), "function" = = typeof Symbol && (w.fn [Symbol.iterator] = n [Symbol.iterator]), w.each ("Boolean Sayı Dize İşlevi Dizi Tarih RegExp Nesne Hata Simgesi" .split (""), işlev (e, t) {l ["[nesne" + t + "]"] = t.toLowerCase ()}); e && e.length işlevindeki C (e) {var t = !! e & & "uzunluk", n = x (e); ! g (e) &&! y (e) && ("dizi" === n || 0 === t || "sayı" == t && t> 0 && t-1 e)} var E = işlevi (e ) {var t, n, r, ben, o, a, s, u, l, c, f, p, d, h, g, y, v,m, x, b = "cızırtı" + 1 * yeni Tarih, w = e.document, T = 0, C = 0, E = ae (), k = ae (), S = ae (), D = fonksiyon (e, t) {return e === t && (f =! 0), 0}, N = {}. hasOwnProperty, A = [], j = A.pop, q = A.push, L = A. itme, H = A.slice, O = fonksiyon (e, t) {için (var n = 0, r = e. uzunluk; n <r; n ++) eğer (e [n] === t) n =; return-1}, p = "işaretli | seçilen | eşzamansız | otofokus | autoplay | kontroller | erteleme | özürlü | gizli | ismap | döngü | çoklu | açık | salt okunur | gerekli | kapsamlı", M = "[\\ x20 \\ t \\ r \\ n \\ f] "R '= "(?:. \\\\ | [\\ w] | [^ \ 0 - \\ xa0]) +", J =" \\ [ "+ M +" * ( "+ R +") (?: "+ M +" * ([* ^ $ | ~] =) "+ M +" * (:!? '((: \\\\?. | [^ \\\\ ']) *)' | \ "((:. \\\\ | [^ \\\\\"]) *) \ "| (" + R ")) |) "+ M +" * \\] "W = ":(" + R") (: \\ (((? '((:. \\\\ | [^ \\\\']) *) '| \ "((:?. \\\\ | [^ \\\\\"]) *) \ ") | ((:?. \\\\ | [^ \\\\ () [\ \]] | | *)) "+ I +".*) \\) |) ", $ = yeni RegExp (M +" + "," g "), B = yeni RegExp (" ^ "+ M +" + | ((?: ^ | [^ \\\]] ) (?: \\\.) *) "+ M +" + $ "," g "), F = yeni RegExp (" ^ "+ M +" *, "+ M +" * "), _ = yeni RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*"), z = yeni RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\] "," g "), X = yeni RegExp (K), U = yeni RegExp (" ^ "+ R +" $ "), V = {ID: yeni RegExp (" ^ # ("+ R +") "), SINIF: yeni RegExp (" ^ \\. ("+ R +") "), ETİKET: yeni RegExp (" ^ ("+ R +" | [*]) "), ATTR: yeni RegExp ("^" + I), PSEUDO: yeni RegExp ("^" + W), ÇOCUK: yeni RegExp ("^ :( sadece | ilk | son | nth | nth-last) - (çocuk | tipi) (: \\ ( "+ M +" * (çift | tek | (([+ -] |) (\\ d *) n |) "+ M +" * (:? ([+ -] | ) "+ M +"* (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: yeni RegExp (" ^ (?: "+ P +") $ "," i "), needsContext : yeni RegExp ("^" + M + "* [> + ~] |:: (hatta | tek | eq | gt | lt | nth | ilk | son) (?: \\ (" + M + "* ((?: ? - \\ d) \\ d *) "+ M +" * \\) |) (= [^ -] |? $)", "i")}, G = / ^ (?: giriş | seçme | textarea | button) $ / i, Y = / ^ h \ d $ / i, Q = / ^ [^ {] + \ {\ s * \ [yerel \ w /, J = / ^ (?: # ([ \ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, K = / [+ ~] /, Z = yeni RegExp ("\\\ ([\\ da -f] {1,6} "+ M +"? | ("+ M +") |.) "," ig "), ee = işlevi (e, t, n) {var r =" 0x "+ t- 65536; return r! == r || n? T: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & r | 56320)}, te = / ([\ 0- \ x1f \ x7f] | ^ -? \ D) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ne = function (e, t) {return t? "\ 0" === e "\ ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1).toString (16) + "": "\\" + e}, re = function () {p ()}, yani = ben (function (e) {return! 0 === e.disabled && ("form" e || e)} içindeki "label", {dir: "parentNode", sonraki: "legend"}); {L.apply (A = H.call (w.childNodes), w.childNodes), A [ w.childNodes.length] .nodeType} yakalamak (e) {L = {geçerlidir: A.length fonksiyonu (örn, t) {q.apply (e H.call (t))}: fonksiyonunu (yani, t ) {var n = e.length, r = 0; süre (e [n ++] = t [r ++]); e.length = n-1}}} oe (e, t, r, i) {var o , s, l, c, f, h, v, m = t && t.ownerDocument, T = t? t.nodeType: 9; if (r = r || [], "string"! = e =! e || 1! == T && 9! == T && 11! == T) r döndürür; eğer (! İ && ((t? T.ownerDocument || t: w)! == d && p (t), t = t || d g)) {halinde (11! == T && (f = J.exec (e))) (o = [1]) {halinde (9 === T) {halinde (! (l = t f. getElementById (o))) r döndürür, eğer (l.id === o) döndürürse r.push (l), r} aksi takdirde (m && (l = m.getElementById (o)) && x (t, l) && l.id === o) r.push (l), r} else {if (f [2]) döndürür L.apply (r, t.getElementsByTagName (e)), r; eğer ((o = f) [3]) && n.getElementsByClassName && t.getElementsByClassName), L.apply (r, t.getElementsByClassName (o)) döndürür, r} if (n.qsa &&! S [e + ""] && (! Y ||! Y.test ( e))) {eğer (1! == T) m = t, v = e; aksi takdirde ("nesne"! == t.nodeName.toLowerCase ()) {(c = t.getAttribute ("id") ) c = c.replace (te, ne): t.setAttribute ( "kimlik", c = c), s = (h = (e)?.) uzunluğu; iken (s -) h [s] = "#" + c + "" + ve (h [s]); v = h.join (","), m = K.test (e) && ge (t.parentNode) || t} (v) denemek {return L.apply (r, m.querySelectorAll (v)), r} catch (e) {} sonunda {c === b && t.removeAttribute ("id")}}} return u (e.replace (B, "$ 1"), t, r, i)} işlevi ae () {var e = []; işlev t (n, i) {return e.push (n + "")> r.cacheLength && delete t [e.shift ()], t [n + ""] = i} return t} işlevi se (e) {return e [b] =! 0, e} işlevi ue (e) {var t = d.createElement ("fieldset") ); deneyin {return !! e (t)} catch (e) {return! 1} sonunda {t.parentNode && t.parentNode.removeChild (t), t = null}} işlev le (e, t) {var n = e.split ("|"), i = n.ength; while (i -) r.attrHandle [n [i]] = t} işlev ce (e, t) {var n = t & e; r = n && 1 = == e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) r döndürür; eğer (n) (n = n.nextSibling) ise (n === t) return-1; e? 1: -1} işlevi fe (e) {return işlevi (t) {return "input" === t.nodeName.toLowerCase () && t.type === e}} işlevi pe (e) {return işlevi (t) {var n = t.nodeName.toLowerCase (); return ("input" === n || "button" === n) && t.type === e}} de (e) {return işlevi (t) {"biçimini" t? t.parentNode &&! 1 === t şeklinde döndür.devre dışı mı? t "etiket" t? "etiketinde t.parentNode? t.parentNode.disabled === e: t.disabled === e: t.isDisabled === e || t.isDisabled! ==! e && ie (t) === e: t.disabled === e: t && t.disabled içindeki "label" === e}} işlevi he (e) {return se (function (t) {return t = + t, se (fonksiyon (n, r) {var i, o = e ([], n.enjth, t), a = o.enjth; iken (a -) n [i = o [a]] && (n [i] =! (r [i] = n [i]))})})} işlevi ge (e) {& nbsp = "undefined"! = e.getElementsByTagName && e} n = oe.support = {}, o = oe.isXML = function (e) {var t = e && (e.ownerDocument || e) .documentElement; return !! t & & "HTML"! == t.nodeName}, p = oe.setDocument = function (e) {var t, i, a = e? e.ownerDocument || e: w; a! == d && 9 === a.nodeType && a.documentElement? (d = a, h = d.documentElement, g =! o ( d) w! == d && (i = d.defaultView) && i.top! == ı && (i.addEventListener? ı.addEventListener ("unload", re,! 1): i.attachEvent && i.attachEvent ("onun yükü", re)), n.attributes = ue (function (e) {return e.className = "i",! e.getAttribute ("className")}), n.getElementsByTagName = ue (function (e) {return e.appendChild (d.createComment ("")) ,! e.getElementsByTagName ("*"). uzunluk}), n.getElementsByClassName = Q.test (d.getElementsByClassName), n.getById = ue (function (e) {return h.appendChild (e) .id = b,! D.getElementsByName ||! D.getElementsByName (b) .length}) , n.getById? (r.filter.ID = function (e) {var t = e.replace (Z, ee); return işlevi (e) {return e.getAttribute ("id") === t}} , r.find.ID = function (e, t) {if ("undefined"! = typ.t.getElementById && g) {var n = t.getElementById (e); return n? [n]: []}}): (r.filter.ID = işlev (e) {var t = e.replace (Z, ee); dönüş işlevi (e) {var n = "tanımsız"!= e.getAttributeNode && e.getAttributeNode ("kimliği"); n = & n.value === t}} döndürün, r.find.ID = işlev (e, t) {if ("undefined"! = typeof t.getElementById && g) { var n, r, i, o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]; i = t.getElementsByName (e) r = 0; iken (o = i [r ++]) halinde ((n = o.getAttributeNode ( "kimlik")) && n.value === e) geri [o]} dönüş [] }}), r.find.TAG = n.getElementsByTagName? function (e, t) {return "undefined"! = typeof t.getElementsByTagName? t.getElementsByTagName (e): n.qsa? t.querySelectorAll (e): void 0}: işlev (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); eğer ("*" === e) {while (n = o [i ++ ]) 1 === n.nodeType && r.push (n); return r} return o}, r.find.CLASS = n.getElementsByClassName && function (e, t) {if ("undefined"! = TgetElementsByClassName && g) döndürür t.getElementsByClassName (e)}, v = [], y = [], (n.qsa = Q.test (d.querySelectorAll)) & & (ue (function (e) {h.appendChild (e) .innerHTML = "<a id='"+b+"'> </a> <select id = '" + b + "- \ r \\' msallowcapture = ''> <seçenek seçildi = ''> </option> </ select>", e.querySelectorAll ( "[msallowcapture ^ = '']") uzunluk && y.push. ( "[* ^ $] =" + M + "* (?: '' | \" \ ")") , e.querySelectorAll ( "[seçilen]") uzunluğu || y.push ( "\\ [" + M + "* (?: değeri |" + P + ")")., e.querySelectorAll ( "[kimlik ~ = "+ b +" -] "). uzunluğu || y.push (" ~ = "), e.querySelectorAll (": "e.querySelectorAll ()" işaretli "() uzunluğu || y.push" işaretli bir # "+ b +" + * "). uzunluğu || y.itme (". #. + [+ ~]")}), ue (function (e) {e.innerHTML = "<a href='' disabled='disabled'> </a> <select disabled = 'devre dışı bırakıldı '> <option /> </select> "; var t = d.createElement (" input "); t.setAttribute (" type "," hidden "), e.appendChild (t) .setAttribute (" name ", "D"), e.querySelectorAll ( "[name = d]") uzunluk && y.push ( "name" + M +. "*? [* ^ $ |! ~] ="), 2 == e.querySelectorAll (! ): "etkin" uzunluk && y.push (. ": etkin", ": devre dışı"! ": devre dışı".) uzunluk && y.push), h.appendChild (e) = 0,2 == e.querySelectorAll (.disabled ( "*.:"), e.querySelectorAll ( "* ,: x") y.push (: "devre dışı", "etkin")})), (n.matchesSelector = Q.test (m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue (fonksiyonu (e) {n.disconnectedMatch = m.call (yani, "*"), m.call (e "[s = ''!]: x "), v.push ("! = ", W)}), y = y.length && yeni RegExp (y.join (" | ")), v = v.length && new RegExp (v.join (" | ") ), t = Q.test (h.compareDocumentPosition), x = t || Q.test (h.contains)? işlevi (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; dönüş e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r) )))}:!? fonksiyonu (yani, t); {halinde (±) ise (t = t.parentNode) halinde (t === e) geri 0; dönüş 1}, D = t fonksiyonu (yani, t ) {eğer (e === t) f =! 0,0; dönüş; var r =! e.compareDocumentPosition-! t.compareDocumentPosition; return r || (1 & (r = (e.ownerDocument || e) == = (t.ownerDocument || t) e.compareDocumentPosition (t): 1) || n!.sortDetached && t.compareDocumentPosition (e) === r e === d || e.ownerDocument === (e, a) ağırlık && x: 1 -? t === d || t.ownerDocument === ağırlık && X (ağırlık , t) 1 1: c O O (c, e) -O (c, t): 0: 4 & r -1 -1: 1)}: işlev (e, t) {eğer (e === t) f döndürür =! 0,0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; eğer (! İ ||! O), e == ? d = 1: t === d 1 i 1: c O (c, e) O (c, t): 1: o?? 0; (i === O) dönüş cE (yani, t), n = e, (n) ise (n = n.parentNode) a.unshift n = t; sırasında (n = n.parentNode) s.unshift (n) (a [r ise ] === s [r]) r ++; dönüş r ce ce (a [r], s [r]): a [r] === w? -1: s [r] === w? 1: 0}, d): d}, oe.matches = function (e, t) {return oe (e, null, null, t)}, oe.matchesSelector = function (e, t) {eğer ((e.ownerDocument) || e)! == d && p (e), t = t.replace (z, "= '$ 1']"), n.matchesSelector && g &&! S [t + ""] && (! v ||! v.test ( t)) && (! y ||! y.test (t))) deneyin {var r = m.call (e, t); eğer (r || n.disconnectedMatch || e.document && 11! == e.document.nodeType) return r} catch (e) {} dönüş oe (t, d, null, [e]). uzunluk> 0}, oe.contains = function (e, t) {return (e.ownerDocument || e)! == d && p (e), x (e, t)}, oe.attr = fonksiyon (e, t) {(e.ownerDocument || e)! == d && p (e); var i = r. attrHandle [t.toLowerCase ()], o = i &&Ncall (r.attrHandle, t.toLowerCase ())? i (e, t,! g): void 0; return void 0! == o? n: n .attributes || g e.getAttribute (t) :( o = e.getAttributeNode (t)) && o.specified o.value:? boş} oe.escape = fonksiyonu (e) {dönüş (e + "") .replace (te, ne)}, oe.error = function (e) {yeni hata at ("Sözdizimi hatası, tanınmayan ifade:" + e)}, oe.uniqueSort = function (e) {var t, r = [ ], i = 0, o = 0, eğer (! f = n.detectDuplicates, c = n.sortStable && e.slice (0), e.sort (D) f) {ise (++] o t = e [) t === e [o] && (i = r.push (o)); süre (i -) e.splice (r [i], 1)}, c = null, e}, i = oe döndürür. getText = function (e) {var t, n = "", r = 0, o = e.nodeType;if (o) {if (1 === o || 9 === o || 11 === o) {if ("string" == e.textContent) yazın e.textContent; için (e = e .firstChild; e; e = e.nextSibling) n + = i (e)} (3 === o || 4 === o), e.nodeValue} ifadesini döndürürse (t = e [r ++]) n + = i (t); dönüş n}, (r = oe.selectors = {cacheLength: 50, createPseudo: se, eşleşme: V, attrHandle: {}, find: {}, göreceli: {">": {dir: "parentNode", önce:! 0}, "": {dir: "parentNode"}, "+": {dir: "öncekiSibling", önce:! 0}, "~": {dir: "priorSibling"}} , preFilter: {ATTR: işlev (e) {dönüş e [1] = e [1]. yerine (Z, ee), e [3] = (e [3] || e [4] || e [5 ] || ""). (Z, ee), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0, 4)}, CHILD: fonksiyon (e) {return e [1] = e [1] .toLowerCase (), "nth" === e [1] .slice (0,3)? (E [3] | ? | oe.error (e [0]), e [4] = + (e [4], e [5] + (e [6] || 1): 2 (* "çift"=== E [3] || "tek" === e [3])) e [5] = + (e [7] + e [8] || "tek" === e [3] )): e [3] && oe.error (e [0]), e}, PSEUDO: işlevi (e) {var t, n =! e [6] && e [2]; döndürün V.CHILD.test (e [0]) boş: (? e [3] e [2] = e [4] || e [5] ||: "" n && X.test (n)! && (t = bir (n, 0) ) && (t = n.indexOf ( ""), n.length-t) -n.length) && (e [0] = e [0] .slice (0, t) e [2] = n. dilim (0, t)), e.slice (0,3))}}, filtre: {TAG: işlevi (e) {var t = e.replace (Z, ee) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, SINIF: işlev (e) {var t = E [e + " "]; t || (t = yeni RegExp (" (^ | "+ M +") "+ e +" ("+ M +" | $) ")) &&E (e, işlev (e) {return t.test ("string" == typeof e.className && e.className || "undefined"! = typeof e.getAttribute && e.getAttribute ("class") || "")})}, ATTR: işlevi (e, t, n) {return işlevi (r) {var i = oe.attr (r, e); return null == i? === t "=": "? ı === t == n!:" =: t || (i + = "", "="? === i === n t" ^ ($ = "=== t n && i.slice: -: = "=== t n && 0 === i.indexOf (n)?" * = "1 === t n && i.indexOf (n)>?"? -n.length) === n: "~ =" === t? ("" + i.replace ($, "") + "") .indexOf (n)> - 1: "| =" = == t && (i === n || i.slice (0, n.length + 1) === n + "-"))}} ÇOCUK: fonksiyonu (e, t, n, r, ı) { var o = "nth"! == e.slice (0,3), a = "son"! == e.slice (-4), s = "türünden" === t; return 1 == = r && 0 === i? function (e) {return !! e.parentNode}: function (t, n, u) {var l, c, f, p, d, h, g = o! == a? "nextSibling": "previousSibling" y t.parentNode, v = s && t.nodeName =.! ToLowerCase (), m = u && s, x = 1;! (Y) {(o) {ise (g) {p = t, (p = p [g]) (s p ise?. nodeName.toLowerCase () === v: 1 === p.nodeType) 1, h = g = "sadece" === e && h && "nextSibling"} geri 0} (h = [a!? y.firstChild: y.lastChild], bir && m), {x = (D = (l = (c = (f = (p = y), [b] || (s [a] = {})) [p.uniqueID ] || (f [p.uniqueID] = {})) [e] || []) [0] === T && l [1]) && l [2], s = d && y.childNodes [d]; iken ( p = ++ d && s &&, p [g] || (x = D = 0) || h.pop ()) halinde (1 === p.nodeType && ++ x && p === t) {c [e] = [T , d, x]; break}} else eğer (m && (x = d = (l = (c = (f = (p = t) [b)) [b] || (p [b] = {})) [p. uniqueID] || (f [p.uniqueID] = {})) [e] || []) [0] === T && l [1]) ,! 1 === x) (p ise = ++ d && s && s [g] || (x = D = 0) || h.pop ()) ise ((lar p.nodeName.toLowerCase () === v: 1 === p.nodeType) && ++ x && ( m && ((c = (f p = [b] || (s [A] = {})) [p.uniqueID] || ([p.uniqueID] f = {})) [e] = [T, x]),p === t)) break; return (x- = i) === r || x% r == 0 && x / r> = 0}}}, PSEUDO: işlev (e, t) {var n, i = r.pseudos [e] || r.setFilters [e.toLowerCase ()] || oe.error ("desteklenmeyen sözde:" + e); dönüş i [b]? i (t): i.length> 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty (e.toLowerCase ())? se (fonksiyon (e, n) {var r, o = i (e, t), a = o.ongth; while (a -) e [r = O (e, o [a])] =! (n [r] = o [a])}): function (e) {return i (e , 0, n)}): i}}, pseudos: {not: se (işlev (e) {vart = [], n = [], r = s (e.replace (B, "$ 1"))) ; return r [b] a se (işlev (e, t, n, i) {var o, a = r (e, null, i, []), s = e.uzun;; (s -) ( o = a [s]) && (e [s] =! (t [s] = o))}): işlev (e, i, o) {return t [0] = e, r (t, null, o, n), t [0] = null,! n.pop ()}}), var: se (function (e) {return işlevi (t) {return oe (e, t). uzunluğu> 0}} ), içerir: se (işlev (e) {dönüş e = e.replace (Z, ee), işlev (t) {dönüş (t.textContent || t.innerText || i (t)). indexOf (e) > -1}}), lang:se (function (e) {return U.test (e || "") || oe.error ("desteklenmeyen lang:" + e), e = e.replace (Z, ee) .toLowerCase (), function ( t) {var n; do {eğer (n = g? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) return (n = n.toLowerCase ()) = == e || 0 === n.indexOf (e + "-")} ise ((t = t.parentNode) && 1 === t.nodeType) dönüş 1}}), hedef: fonksiyonu (t)! {var n = e.location && e.location.hash; return n && n.slice (1) === t.id}, root: function (e) {return e === h}, focus: function (e) {return (! d.hasFocus || d.hasFocus ()) e === d.activeElement && && !! (e.type || e.href || ~ e.tabIndex)}, etkin: (! 1) de, özürlü : de (! 0), işaretli: function (e) {var t = e.nodeName.toLowerCase (); "giriş" döndür "=== t && !! e.checked ||" option "=== t && !! e .selected}, selected: function (e) {return e.parentNode && e.parentNode.selectedIndex ,!e.selected 0 ===} boş: için fonksiyon (e) {(E; e = e.firstChild e = e.nextSibling) halinde (e.nodeType <6) 1 dönmek; dönüş 0}, üst! : function (e) {return! r.pseudos.empty (e)}, başlık: function (e) {return Y.test (e.nodeName)}, input: function (e) {return G.test (e. nodeName)}, button: function (e) {var t = e.nodeName.toLowerCase (); "input" === t && "button" === e.type || "button" === t} döndürün, text: function (e) {var t; "giriş" döndür = == e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("type"))) || "metin" === t.toLowerCase ())}, ilk: o (fonksiyonu () {[0]}), son geri: o (fonksiyonu (yani, t) {geri [f-1]}) , eq: he (fonksiyon (e, t, n) {return [n <0? n + t: n]}), hatta: he (fonksiyon (e, t) {için (var n = 0; n <t ; n + = 2) e.push (n); dönüş e}), tek: he (fonksiyon (e, t) {için (var n = 1; n <t; n + = 2) e.push (n); dönüş e}), lt: he (fonksiyon (e, t,n) {((r = n <0? n + t: n; - r> = 0;) e.push (r); dönüş e}), gt: he (fonksiyon (e, t, n) {((r = n <0? n + t: n; ++ r <t;) e.push (r); dönüş e})}}) .pseudos.nth = r.pseudos.eq; t {radio:! 0, onay kutusu:! 0, dosya:! 0, şifre:! 0, resim:! 0}) r.pseudos [t] = fe (t); için ({in: gönder! , reset:! 0}) r.pseudos [t] = pe (t); işlevini y () {} ye.prototype = r.filters = r.pseudos, r.setFilters = yen, a = oe.tokenize = işlevi (e, t) {var n, i, o, a, s, u, l, c = k [e + ""]; eğer (c) t = 0 döndürürse: c.slice (0); s = e u = [], i = r.preFilter;! ise (ler) i {n && (i = F.exec (ler)) || (i && (s = s.slice (i [0] .length) || s !.), u.push (o = [])), n = 1 olduğunda (i = _ exec (ler)) && (n = i.shift (), o.push ({değeri: n, tip i [0] .blace (B, "")}), s = s.slice (n.length)); (a. R.filter)! (İ = V [a] .exec (s)) || ! l [a] && (i = l [a]: (i)) || (n = i.shift (), o.push ({değeri: n, tip: a, eşleşen i}), ş = s .slice (n.length)); eğer (! n) break} döndürürse t? s.length: s? oe.error (e):k (e, u) .slice (0)}; fonksiyon ve (e) {için (var t = 0, n = e.length, r = ""; t <n; t ++) r + = e [t]. değer; return r} fonksiyonu me (e, t, n) {var r = t.dir, i = t.next, o = i || r, a = n & & "parentNode" === o, s = C ++; t.first? fonksiyonunu döndürür (t, n, i) {while (t = t [r]) eğer (1 === t.nodeType || a) e döndür (e, t, n, i); return! 1} : function (t, n, u) {var l, c, f, p = [T, s]; if (u) {while (t = t [r]) eğer ((1 === t.nodeType | | a) && e (t, n, u))! 0} ifadesini döndürürken (t = t [r]) eğer (1 === t.nodeType || a) eğer (f = t [b] || ( t [b] = {}), c = f [t.uniqueID] || (f [t.uniqueID] = {}) i && i === t.nodeName.toLowerCase ()) t = t [d] | | t; else {if ((l = c [o]) && l [0] === T && l [1] === s) p [2] = l [2] döndürürse, (c [o] = p , p [2] = e (t, n, u)) return! 0} return! 1}} işlevi xe (e) {return e.length> 1? function (t, n, r) {var i = e .length; iken (i -) eğer (! e [i] (t, n, r))!! 1; dönüş! 0}: e [0]} işlevi (e, t, n) {için ( var r = 0, i = t. uzunluk; r <i; r ++) oe (e, t [r], n); dönüş n} fonksiyonu biz (e, t, n,r, i) {için (var o, a = [], s = 0, u = e. uzunluk, l = null! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s))); a} işlevini döndür Te (e, t, n, r, i, o) {return r! [b] && (r = Te (r)), i &&! i [b] && (i = Te (ı, o)), se (işlevi (o, a, s, u) {var l, c, f !, p = [], d = [], s = a.length, g = o || olarak (? t || "*", s.nodeType [s]: c, []), y = e | !?? | o && Tg: biz (g p, e, s, u) v = i n || (? o e: e || r) []: bir y, eğer (n && n (y, v, s, u), r) {l = biz (v, d), r (l, l [], u), c = l.length, s; ise (c -) (= l [f c] ) && (v [d [c]] =! (y [d [c]] = f))} (o) {(yani || varsa) {(i) {l = [], c = v.length; ise (c -) (Rf = hac [c]) && l.push (y [c] = f) 'i (null, v = [], i, u)} c = v.length; ise (c -) (Rf = hac [c]) && (l = i O (O, f): Ç [c])> - 1 && (o [i] = (a [l] = f)! )}} else v = biz (v === a? v.splice (h, v.length): v), i? i (null, a, v, u): L.apply (a, v)} )} ce (e) {{(var t, n, i, o = e.ength, a = r.relative [e [0] .type], s = a || r.göreceli [""], u = a? 1: 0, c = me (işlev (e) {return e === t}, s,! 0), f = me (işlev (e) {return O (t , e)> - 1}, s,! 0), p = [fonksiyon (e, n, r) {var i =! a && (r || n! == l) || ((t = n). nodeType? c (e, n, r): f (e, n, r)); dönüş t = null, i}]; u <o; u ++) eğer (n = r.relative [e [u] .type ]) p = [me (Xe (s), n)]; başka {halinde ((n = r.filter [e [u] .Tip] .apply (null e [u] .matches)) [b] ) {((i = + +; i; o; i + +)) eğer (r.relative [e [i]. tipi]) kırılırsa, Te (u> 1 && xe (p), u> 1 && ve (e.slice ( 0, u-1) .concat ({değer: "" === e [u-2] .type? "*": ""})). Yerine (B, "$ 1"), n, u <& & Ce (e.slice (u, i)), i <o && Ce (e = e.slice (i)), i <o && ve (e))} p.push (n)} return xe (p)} işlevi Ee (e , t) {var n = t. uzunluk> 0, i = e.length> 0, o = fonksiyon (o, a, s, u, c) {var f, h, y, v = 0, m = " 0" , burada x = o && [], b = [], = l, C = o || i && r.find.TAG w ( "*", c), e = T + = boş == 1 ağırlık: Math.Rastgele () || .1, k = C.length (c && (l = bir === d || bir || c) için;! m == K && boş = (f = C [m]);! m ++ ) {), g = s (i f) {h = 0, bir || f.ownerDocument === d || (s (f &&) ise;! (y = e [h ++]) (y (f ise, bir || d, s)) {u.push (f) 'ara}! c && (T = s)}, n && ((f = y && f) && v -, o && x.push (f))} halinde (d + m = n && m == h) {h = 0; ise (y = z [h ++]) y (x, b, a, s); if (o) {durumunda (v> 0) ise (m -) x [m] || b [m] || (b [m] = j.call (u));! b = biz, (b)} L.apply (u, b), c && o && b.length> 0 && d + t .length> 1 && oe.uniqueSort (u)} return c && (T = E, l = w), x}; return n? se (o): o} return s = oe.compile = function (e, t) {var n, r = [], i = [], o = S [e + ""]; eğer (! o) {t || (t = a (e)), n = t. uzunluğu; ) (o = Ce (t [n])) [b] r.push?. (o): i.push (o) (= S (e ile (i, r) o)) seçici = e} dönüş o}, u = oe.select = işlev (e, t, n, i) {var o, u, l, c, f, p = "işlev" == e && e, d =! i &&a (e = p .Seçici || e)Eğer (n = n || [], 1 === d.length) ((u d = halinde {[0] = D [0] .slice (0)). uzunluğu> 2 && "İD" === ( l = u [0]). && 9 === t.nodeType && g && r.relative [u [1] .Tip]) {halinde (! (t = (r.find.ID (l.matches [0] .Kapağı (Z tip , ee), t) || []) [0])), n; p && (t = t.parentNode), e = e.slice (u.shift (). value.length)} o = V.needsContext değerini döndürün. .test (e) 0: u.length; iken (o -) {(l = u [o], r.relative [c = l.type]) kesme, eğer ((Rf = r.find [ -c]) && (i = f (l.matches [0] .Kapağı (Z, ee), K.test (u [0] .Tip) && ge (t.parentNode) || t))) {halinde (u .splice (o, 1),! (e = i.ength && ve (u))) L.apply (n, i), n; break}}} return (p || s (e, d)) (i , t,! g, n,! t || K.test (e) && ge (t.parentNode) || t) n} n.sortStable = b.split ( ""). sıralama (D) .join ("") === b, n.detectDuplicates = !! f, p (), n.sortDetached = ue (function (e) {return 1 & e.compareDocumentPosition (d.createElement ("fieldset"))}),ue (function (e) {return e.innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute ("href")}) || le (" type | href | height | width ", function (e, t, n) {if (! n) return e.getAttribute (t," type "=== t.toLowerCase ()? 1: 2)}), n .attributes && ue (işlev (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("değer", ""), "" === e.firstChild.getAttribute ("değer")} ) || le ("değer", işlev (e, t, n) {if (! n && "input" === e.nodeName.toLowerCase ()), e.defaultValue} döndürür, ue (function (e) { return null == e.getAttribute ("disabled")}) || le (P, işlevi (e, t, n) {var r; eğer (! n)!! 0 === e [t]? t. toLowerCase () :( r = e.getAttributeNode (t)) && r.specified r.value: boş}), oe} (e) w.find = e w.expr = E.selectors, w.expr [ ":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape; var k = işlevi (e, t, n) {var r = [], i = geçersiz 0! == n; iken ((e = e [t]) && 9! == e.nodeType) eğer (1 === e.nodeType ) {if (i & w (e) .is (n)) sonu; r.push (e)} return r}, S = işlevi (e, t) {için (var n = []; e; e = e. nextSibling) 1 === e.nodeType && e! == t && n.push (e); dönüş n}, D = w.expr.match.needsContext; fonksiyon N (e, t) {return e.nodeName && e.nodeName.toLowerCase ( ) === t.toLowerCase ()} var A = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; işlev j (e, t, n) {dönüş g (t)? w.grep (e, işlev (e, r ) {return !! t.call (e, r, e)! == n}): t.nodeType? w.grep (e, işlevi (e) {return e === t! == n}): "string"! = t = w.grep (e, fonksiyon (e) {dönüş u.call (t, e)> - 1! == n}): w.filter (t, e, n)} w .filter = fonksiyon (e, t, n) {var r = t [0];dönüş n && (e = ": değil (" + e + ")"), 1 === t.length && 1 === r.nodeType? w.find.matchesSelector (r, e)? [r]: []: w .find.matches (e, w.grep (t, fonksiyon (e) {return 1 === e.nodeType}))}, w.fn.extend ({find: function (e) {var t, n, r = this.length, i = this; eğer ("string"! = e) 'e yazın this.pushStack (w (e) .filter (function () {için (t = 0; t <r; t ++)) ( n = this.pushStack ([]), t = 0 için (;!; w.contains (i [t], bu)) 0})) geri t <r; t ++) w.find (e, i: [t ], n); return r> 1? w.uniqueSort (n): n}, filter: function (e) {return this.pushStack (j (bu, e || [] ,! 1))}, değil: function (e) {return this.pushStack (j (bu, e || [] ,! 0))}, şöyledir: function (e) {return !! j (bu, "string" == e ve&d. e)? w (e): e || [] ,! 1). uzunluk}}); var q, L = / ^ (?: \ s * (<[\ w \ W] +>) [^> ] * | # ([\ w -] +)) $ /; (w.fn.init = function (e, t, n) {var i, o; if (! e) şunu döndürür; eğer (n = n || q, "string" == e) yazın {if (! (i = "<"=== e [0] &&"> "=== e [e.length-1] && e.length> = 3 [boş, örneğin, boş]:! L.exec (e)) || i [ 1] && t) geri t || t.jquery (t || n) .find (e):? this.constructor (t) .find (e) (i [1]) {halinde (t = t w? t [0]: t, w.merge (bu, w.parseHTML (i [1], t & & t.nodeType? t.ownerDocument || t: r,! 0)), A.test (i [1] ]) && w.isPlainObject (t)) (i in t) g (bu [i]) için? bu [i] (t [i]) için: this.attr (i, t [i]); (o = r.getElementById (i [2])) && (this [0] = o, this.length = 1), this} return e.nodeType? (this [0] = e, this.length = 1, this): g (e)? void 0! == n.ready? n.ready (e): e (w): w.makeArray (e, this)}). prototip = w.fn, q = w ( r); var H = / ^ (?: parent | prev (?: | Tümüne Kadar)) /, O = {çocuklar:! 0, içerikler:! 0, sonraki:! 0, önceki:! 0}; w. fn.extend ({has: function (e) {var t = w (e, bu), n = t.length; return this.filter (function () {için (var e = 0; e <n; e ++) ! (w.contains (bu, t [e])) 0})}, en yakın dönmek: fonksiyonu (e,t) {var n, r = 0, i = this.length, o = [], a = "string"! = e && w (e); eğer (! D.test (e)) için (; r <i , r ++), (n = bu [d] n && n == d; n = n.parentNode) halinde (n.nodeType <11 && (a a.index (n)?> - 1: 1 === n!. nodeType && w.find.matchesSelector (n, e))) {o.push (n); break} return this.pushStack (o.length> 1? w.uniqueSort (o): o)}, index: function (e) {return e? "string" == e? u.call (w (e), bu [0]): u.call (bu, e.jquery? e [0]: e): bu [0] & & this [0] .parentNode? This.first (). PrevAll (). Uzunluk: -1}, add: function (e, t) {return this.pushStack (w.uniqueSort (w.merge (this.get (), w (e, t))))}, addBack: function (e) {return this.add (null == e? this.prevObject: this.prevObject.filter (e))}}), fonksiyon P (e, t) {while ((e = e [t]) && 1! == e.nodeType); e} w.each ({parent: function (e) {var t = e.parentNode; return t && 11! == t .nodeType t:? null}, anne:function (e) {return k (e, "parentNode")}, parentsUntil: function (e, t, n) {return k (e, "parentNode", n)}, sonraki: function (e) {return P ( e, "nextSibling")}, prev: function (e) {dönüş P (e, "öncekiSibling")}, nextAll: function (e) {dönüş k (e, "nextSibling")}, prevAll: function (e) {return k (e, "öncekiSibling")}, nextUntil: function (e, t, n) {return k (e, "nextSibling", n)}, prevUntil: function (e, t, n) {return k ( e, "öncekiSibling", n)}, kardeşler: function (e) {return S ((e.parentNode || {}). firstChild, e)}, children: function (e) {return S (e.firstChild) }, content: function (e) {geri dön N (e, "iframe")? e.contentDocument: (N (e, "şablon") && (e = e.content || e), w.merge ([] , e.childNodes))}}, işlev (e, t) {w.fn [e] = işlev (n, r) {var i = w.map (bu, t, n); = e.slice (-5) && (r = n) r-& "string" == r && yazımı (i = w.filter (r, i)), this.length> 1 && (O [e] || w.uniqueSort (i), H.test (e) && i.reverse ( )), this.pushStack (i)}}); var M = / [^ \ x20 \ t \ r \ n \ f] + / g; fonksiyon R (e) {var t = {}; (e.match (M) || [], işlev (e, n) {t [n] =! 0}), t} w.Callbacks = işlev (e) {e = "string" == e R (e): w.extend ({}, e); var t, n, r, i, o = [], a = [], s = -1, u = function () {için (i = i || e.once, r = t = 0;! a.length, s = 1) {n = a.shift (;) ise (++ s <o.length) 1 === o [s] .apply (n [0] n [1]) && e.stopOnFalse && (s = o.length, n! = 1)} e.memory || (n =! 1), Rt =! 1 i && (o = n? []: "")}, l = {add: function () {return o && (n &&! t && (s = o.lendth-1, a.push (n)), t (n) {w. her bir (n, fonksiyon (n, r) {gr (r) e.unique && l.has (r) || o.push (r): r! && r.length && "dizge" == x (r) && t (r) })} (bağımsız), n-&&! t &&u ()), bu}, remove: function () {return w.each (argümanlar, function (e, t) {var n; while ((n = w.inArray (t, o, n))> - 1 ) o.splice (n, 1), n ​​<= s && s -}), bu}, var: işlevi (e) {return e? w.inArray (e, o)> - 1: o.length> 0} , empty: function () {return o && (o = []), bu}, disable: function () {return i = a = [], o = n = "", bu}, disabled: function () {return ! o}, lock: function () {return i = a = [], n || t || (o = n = ""), bu}, kilitli: function () {return !! i}, fireWith: işlevi (e, n) {return i || (n = [e, (n = n || []). dilim? n.slice (): n], a.push (n), t || u ( )), this}, fire: function () {return l.fireWith (this, argümanlar), this}, fired: function () {return !! r}}; return l}; function I (e) {return e } işlev W (e) {fırlatma e} işlevi $ (e, t, n, r) {var i; deneyin {e && g (i = e.promise)? i.call (e) .done (t) .fail ( n): e && g (i = e. sonra)? i.call (e, t, n): t.apply (geçersiz 0, [e] .slice (r))} catch (e) {n.apply (void) 0, [e])}} w.extend ({Ertelenen: function (t) {var n = [["bildir", "ilerleme", w.Aramalar ("bellek"), w.Aramalar ("bellek"), 2], ["çöz", " bitmiş ", w.Callbacks (" bir kez bellek "), w.Callbacks (" bir kez bellek "), 0," çözüldü "], [" reddet "," başarısız ", w.Callbacks (" bir kez bellek "), w Geri aramalar ("bir kez bellek"), 1, "reddedildi"]], r = "beklemede", i = {state: function () {return r}, her zaman: function () {return o.done (arguments). fail (argümanlar), bu}, "catch": function (e) {return i.then (null, e)}, pipe: function () {var e = arguments; return w.Deferred (function (t) {w .each (n, fonksiyon (n, r) {var i = g (e [r [4]]) && e [r [4]]; o [r [1]] (fonksiyon () {var e = i & i. ?. uygulamak (bu, argümanlar); e && gr (e.promise) e.promise () ilerleme (t.notify) .done (t.resolve) .fail (t.reject):t [R [0] + "ile"] (bu, i [e]: argümanlar).})}), e = boş}) söz ()}, o zaman: fonksiyonu (t, r i) {var o = 0; işlev a (t, n, r, i) {return işlev () {var s = bu, u = değişkenler, l = işlev () {değişken e, l; eğer (! (t <o)) {if ((e = r.apply (s, u))) === n.promise ()) yeni TypeError ("Sonra Çözülebilir Çözünürlük") atın; l = e && ("object" == typeof e || " fonksiyonu "== e) yazın & & e.then, g (l)? i? l.call (e, a (o, n, ı, i), a (o, n, W, i)) :( o ++, l.call (yani, bir (o, n, i, i) bir (o, n, W, i) bir (o, n, I, n.notifyWith))) :( r! == ı && ( s = geçersiz 0, u = [e]), (i || n.resolveWith) (s, u))}}, c = i? l: function () {try {l ()} catch (e) { w.Deferred.exceptionHook && w.Deferred.exceptionHook (e, c.stackTrace), t + 1> = o && (r! == W && (s = geçersiz 0, u = [e]), n.rejectWith (s, u) )}}; t? c () :( w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook ()), e.setTimeout (c))}} return w.Deferred (function (e) {n [0] [3].(? A (0, E, G, (i i): I, e.notifyWith)) ekleyin, N [1] [3] .Add (? A (0, e, g (t) t: l)), n [2] [3] .add (a (0, e, g (r)? r: W))}). promise ()}, promise: işlev (e) {return null! = e? w.extend (e, i): i}}, o = {}; dönüş w.each (n, fonksiyon (e, t) {var a = t [2], s = t [5]; i [t [1] ] = a.add, s && a.add (fonksiyonu () {r = s}, n [3-e] [2] .disable, n [3-e] [3] .disable, n [0] [2] .lock, n [0] [3] .lock), a.add (t [3] .fire), o [t [0]] = function () {dönüş o [t [0] + "With"] (this === o? void 0: this, argümanlar), this}, o [t [0] + "İle"] = a.fireWith}), i.promise (o), t && t.call (o, o ), o}, when: function (e) {var t = arguments.length, n = t, r = Array (n), i = o.call (argümanlar), a = w.Deferred (), s = function (e) {return işlevi (n) {r [e] = bu, i [e] = arguments.length> 1? o.call (değişkenler): n, - t || a.resolveWith (r, i) }};.! (t <= 1 && ($ (yani, a.done (s (n)), gidermek a.reject, t); === a.state () "beklemede" || g (i ise [n] && i [n]. sonra))) a.then () işlevini döndürür;while (n -) $ (i [n], s (n), a.reject); dönüş a.promise ()}}); var B = / ^ (Eval | Internal | Range | Reference | Syntax | Type | URI) Hata $ /; w.Deferred.exceptionHook = function (t, n) {e.console && e.console.warn && t && B.test (t.name) && e.console.warn ("jQuery.Deferred istisna:" + t. mesaj, t.stack, n)}, w.readyException = function (t) {e.setTimeout (function () {throw t})}; var F = w.Deferred (); w.fn.ready = function ( e) {return F.then (e) ["catch"] (işlev (e) {w.readyException (e)}), bu}, w.extend ({isReady:! 1, readyWait: 1, ready: function (e) {(! 0 === e - w.readyWait:? w.isReady) || (w.isReady = 0, 0 == e && - w.readyWait> 0 || F.resolveWith!! (r, [w]))}}), w.ready.then = F.then; function _ () {r.removeEventListener ("DOMContentLoaded", _), e.removeEventListener ("load", _), w .ready ()} === r.readyState || "yükleme" "tam"! == r.readyState &&! r.documentElement.doScroll? e.setTimeout (w.ready) :( r.addEventListener ("DOMContentLoaded", _), e.addEventListener ("load", _)); var z = işlevi (e, t, n, r, i, o, a) {var s = 0, u = e.length, l = null == n; eğer ("nesne" === x (n)) {i =! 0; ( n (s) z (e, t, s, n [s],! 0, o, a)} else eğer (boşluk 0! == r && (i =! 0, g (r) || (a =! 0), l && (a? (T.call (e, r), t = null) :( l = t, t = işlev (e, t, n) {return l.call (w (e), n) })), t)) için (s <u s ++), t (e [s], n, a r: r.call (e [s], s, t, (e [s], n)) ); return i? e: l? t.call (e): u? t (e [0], n): o}, X = / ^ - ms - /, U = / - ([az]) / g; işlevi V (e, t) {dönüş t.toUpperCase ()} işlevi G (e) {dönüş e.replace (X, "ms -"). yerine (U, V)} var Y = işlev (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + e.nodeType}; işlev Q () {this.expando = w.expando + Q.uid ++} Q.uid = 1, Q.prototype = {cache: function (e) {var t = e [this.expando]; return t || (t = {}, Y (e) && (e.nodeType E [this.expando] = t: Object.defineProperty (e this.expando {değeri: t, yapılandırılabilir: 0}))) t}, set: fonksiyonu (E, T, n) {var r, i = this.cache (e); if ("string" == typeof t) i [G (t)] = n; (r in t) i [G (r)] = t [r] ; i} return, olsun: function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [G (t)]}, erişim : function (e, t, n) {return void 0 === t || t && "string" == t && void 0 === n? this.get (e, t) :( this.set (e, t , n), geçersiz 0! == n? n: t)}, kaldır: function (e, t) {var n, r = e [this.expando]; eğer (geçersiz 0! == r) {eğer ( void 0! == t) {n = (t = Array.isArray (t)? t.map (G) :( t = G (t)) r? [t]: t.match (M) || []). uzunluğu; (n -) silmek r [t [n]]} (void 0 === t || w.isEmptyObject (r)) && (e.nodeType? e [this.expando] = void 0: e [this.expando])}} silin, hasData: function (e) {var t = e [this.expando]; return void 0! == t &&! w.isEmptyObject (t)}}; var J = yeni Q, K = yeni Q, Z = / ^ (?:\ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, ee = / [AZ] / g; işlevi te (e) {return "true" === e ! || "false" == e && ( "boş" === e boş:?? e === + e + "" + e: Z.test (e) JSON.parse (e):? e)} fonksiyonu ne (e, t, n) {var r; eğer (void 0 === n && 1 === e.nodeType) eğer (r = "data -" + t.replace (ee, "- $ &"). toLowerCase (), "string" == typeof (n = e.getAttribute (r))) {deneyin {n = te (n)} yakalamak (e) {} K.set (e, t, n)} else n = void 0; dönüş n} w.extend ({hasData: function (e) {dönüş K.hasData (e) || J.hasData (e)}, veri: function (e, t, n) {return K.access (e, t, n)}, removeData: function (e, t) {K.remove (e, t)}, _ veri: function (e, t, n) {return J.access (e, t, n) }, _ removeData: function (e, t) {J.remove (e, t)}}), w.fn.extend ({data: function (e, t) {var n, r, i, o = this [ 0], a = o && o.attributes; if (void 0 === e) {if (this.length && (i = K.get (o), 1 === o.nodeType &&! J.get (o, "hasDataAttrs) "))) {N = a.length; sırasında (n -) bir [n] && 0 === (r = a [n] .name) .indexOf ( "Veri -") && (R = G (r. dilim (5)), ne (o, r, i [r])); J.set (o, "hasDataAttrs",! 0)} return i} return "nesne" = = e () {K.set (bu, e)}): z (bu, fonksiyon (t) {var n; eğer (o & & void 0 === t) {if (void 0! == (n = K.get ( o, e)))) n döndürür, eğer (void 0! == (n = ne (o, e))) n döndürürse n} this.each (function () {K.set (this, e, t)} )}, null, t, arguments.length> 1, null,! 0)}, removeData: function (e) {return this.each (function () {K.remove (this, e)})}}), w.extend ({sıra: işlev (e, t, n) {var r; eğer (e), t = (t || "fx") + "sıra", r = J.get (e, t) döndürür, n && (r || Array.isArray (n) r = J.access (e, t, n w.makeArray ()):? r.push (n)), r || []}, sıradan çıkarma: fonksiyonu ( e, t) {t = t || "fx"; var n = w.queue (e, t), r = n.length, i = n.shift (), o = w._queueHooks (e, t) a = fonksiyonu () {w.dequeue (yani, t)}; "InProgress"=== i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("devam ediyor"), o.stop öğesini silin, i.call (e, a, o) ) ,! r && o && o.empty.fire ()}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; return J.get (e, n) || J.access (e, n, {empty) : w.Callbacks ("bir kez bellek"). add (function () {J.remove (e, [t + "sıra", n])})})}}), w.fn.extend ({kuyruk: işlev (e, t) {var n = 2; "string"! = = e && (t = e, e = "fx", n -), arguments.length <n? w.queue (this [0], e): void 0 === t? this: this.each (function () {var n = w.queue (this, e, t); w._queueHooks (this, e), "fx" === e && "inprogress"! == n [0] && w.dequeue (this, e)})}, dequeue: function (e) {return this.each (function () {w.dequeue (this, e)})}, clearQueue: function (e) {return this.queue (e || "fx", [])}, söz ver: function (e, t) {var n, r = 1, i = w.Ertelenmiş (), o = bu, a = this.length, s = function () {- r || i.resolveWith (o, [o])}; "string"! = E ve& (t = e, e = void 0), e = e || "fx"; süre (a -) (n = J.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add ( s)); s (), i.promise (t)}} döndürün; var re = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -] ? \ d + |) /. kaynak, yani = yeni RegExp ("^ (?: ([+ -]) = |) (" + re + ") ([az%] *) $", "i"), oe = [ "en", "sağ", "alt", "sol"], ae = fonksiyonu (yani, t) {dönüş "yok" === (e = t || e) .style.display ||" "=== e.style.display && w.contains (e.ownerDocument e) &&" yok "=== w.css (yani," görüntü ")}, se = fonksiyonu (yani, t, n, r) { var i, o, a = {}; (t'deki o) a [o] = e.style [o], e.style [o] = t [o]; i = n.apply (e, r | | []); (t de) için e.style [o] = a [o]; dönüş i}; fonksiyon ue (e, t, n, r) {var i, o, a = 20,s = r? function () {return r.cur ()}: function () {return w.css (e, t, "")}, u = s (), l = n && n [3] || (w ? .cssNumber [t]: "" "piksel" (!), c = w.cssNumber [t] || "piksel" == l && + u) && ie.exec (w.css (yani, t)), eğer (c! && c [3] == l) {u / = 2, l = l || c [3], c = + u || 1; ise, (a -) w.style (e, t, c + l), (1-o) * (1- (o = s () / u || .5)) <= 0 && (a = 0), c / = o, c * = 2, w.style (e , t, c + l), n = n || []}, n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1) * n [ 2]: + n [2], r && (r.unit = l, r.start = c, r.end = i)), i} var le = {}; fonksiyon ce (e) {var t, n = e.ownerDocument, r = e.nodeName, i = le [r]; return i || (t = n.body.appendChild (n.createElement (r)), i = w.css (t, "display") , t.parentNode.removeChild (t), "none" === i && (i = "blok"), le [r] = i, i)} işlev fe (e, t) {için (var n, r, i = [], o = 0, a = e.length; o <a; o ++) (r = e [o]) stil && (n = r.style.display, t, ( "yok" === n.?Ve (ı [o] = J.get (r, "ekran") || boş i [o] || (r.style.display = "")) "" === r.style.display && ae ( r) && (i [o] = ce (r))): "yok" == n && (i [o] = "yok", J.set (r, "ekran" n))); için ( o = 0; o <a; o ++) null! = i [o] && (e [o]. style.display = i [o]); e} w.fn.extend ({show: function () { dönüş fe (this,! 0)}, hide: function () {return fe (this)}, toggle: function (e) {return "boolean" == typeof e? e? this.show (): this.hide (): this.each (function () {ae (bu)? w (bu) .show (): w (bu) .hide ()})}}); var pe = / ^ (?: onay kutusu | radyo ) $ / i de / <([az] [^ \ / \ 0> \ x 20 \ t \ r \ n \ f] +) / i, o = = / ^ $ | ^ modülü $ | \ / (? : java | ecma) script / i, ge = {seçenek: [1, "<çoklu seç = 'çoklu'>", "</select>"], thead: [1, "<table>", "</ tablo> "], sütun: [2," <tablo> <COLGROUP>" "</ COLGROUP> </ table>"], t,: [2, "<Tablo> <tbody>", "</ tbody> </ table>"], td: [3," <tablo> < tbody> <tr>", "</ tr> </ tbody> </ table>"] _ varsayılan: [0 "", ""]}; ge.optgroup = ge.option, ge.tbody = ge. tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; fonksiyon siz (e, t) {var n; dönüş n = "undefined"! = typ.e e.getElementsByTagName? e.getElementsByTagName ( t || "*"): "undefined"! = e.querySelectorAll? e.querySelectorAll (t || "*"): [], geçersiz 0 === t || t & N (e, t)? w. birleştirme ([e], n): n} işlevi ve (e, t) {için (var n = 0, r = e.length; n <r; n ++) J.set (e [n], "globalEval" ,! t || J.get (t [n], "globalEval"))} var me = / <| & #? \ w +; /; işlev xe (e, t, n, r, i) {için ( var o, a, s, u, l, c, f = t.createDocumentFragment (),p = [], d = 0, h = e.length d <h d ++) halinde ((o = E [d]) || 0 === O) ( "nesne" === x (o )) w.merge (p, o.nodeType? [o]: o); aksi halde (me.test (o)) {a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || [ "", ""]) [1] .toLowerCase () u ge = [s] || ge._default, a.innerHTML = u [1] + w.htmlPrefilter (o) + u [2], c = u [0]; ise (c -), a = a.lastChild; w.merge (s, a.childNodes), (a = f.firstChild) .textContent =" "} else p.push (t.createTextNode (o)); f.textContent =" ", d = 0; süre (o = p [d ++]) eğer (r && w.inArray (o, r)> - 1) i && .push (o); else eğer (l = w.contains (o.ownerDocument, o), a = ye (f.appendChild (o), "script"), l && ve (a), n) {c = 0; while (o = a [c ++]) he.test (o.type || "") && n.push (o)} return f}! function () {var e = r.createDocumentFragment (). appendChild (r.createElement) ( "div")), t = r.createElement ( "giriş"); t.setAttribute ( "tip", "radyo"), t.setAttribute, t.setAttribute ( "ad", "t"), e.appendChild (t), h.checkClone = e ( "işaretli" "işaretli"). cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, e.innerHTML = "<metinalanı> x </ textarea>", h.noCloneChecked = !! e.cloneNode (! 0) .lastChild.defaultValue} ( ); var be = r.documentElement, biz = / ^ tuşu /, Te = / ^ (?: fare | pointer | contextmenu | drag | drop) | tıklayın /, Ce = / ^ ([^.] *) (? : \. (. +) |) /; işlevi Ee () {return! 0} işlevi ke () {return! 1} işlevi Se () {deneyin {return {return r.activeElement} catch (e) {}} işlev De (e, t, n, r, i, o) {var a, s; if ("object" == typeof t) {"string"! = typeof n && (r = r || n, n = geçersiz 0) ; (s için t) De (e, s, n, r, t [s], o); eğer e} döndürürseniz (null == r && null == i? (i = n, r = n = geçersiz 0) : null == i && ("string" == typeof n? (i = r, r = boşluk 0) :( i = r, r = n, n = boşluk 0)),! 1 === i) i = ke;Aksi halde (! i), e = döndürür 1 === o && (a = i, (i = işlevi (e) {döndürün w (). kapalı (e), a.apply (bu, argümanlar)}). = a.guid || (a.guid = w.guid ++)), e.each (fonksiyonu () {w.event.add (bu, t, i, r, n)})} w.event = {küresel : {}, add: function (e, t, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, y = J.get (e) (y) {n.handler && (n = (o = n) .handler i = o.selector) i (olmak, i) n.guid || w.find.matchesSelector && halinde (n.guid w =. guıd ++), (u = y.events) || (u = y.events = {}), (a = y.handle) || (a = y.handle = fonksiyonu (t), {dönüş "tanımsız"! = w && w.event.triggered! == t.type? w.event.dispatch.apply (e, argümanlar): void 0}), l = (t = (t || ""). match (M) || [ ""]) uzunluğu;. (l -) d = g = (s = Ce.exec (t [l]) ise || []) [1], h = (lar [2] || "" ) .split () sıralama () = w.event.special [d] || {}, d = (i f.delegateType f d && ( "":.? f.bindType) || d, f w = .event.special [d] || {}, c = w.extend ({türü: d, origType: g, veriler: r,işleyicisi: n, rehberlik: n.guid, seçici: i needsContext: h.join ( "").} o), (p = U [d i w.expr.match.needsContext.test (i) ad && ]) || ((p = u [d] = []). delegateCount = 0, f.setup &&! 1! == f.setup.call (e, r, s, a) '|| e.addEventListener && e.addEventListener (d, a)), (f.add.call (yani, c) c.handler.guid || && f.add (c.handler.guid = n.guid)), i? p.splice (s. delegateCount ++, 0, c): p.push (c), w.event.global [d] =! 0)}}, kaldırın: function (e, t, n, r, i) {var o, a, s u, I, c, F, p, h, q, y = J.hasData (e) && J.get (e) (y && (u = y.events)) {l = (t = ( t || "".) eşleştiği (M) || [ ""]) uzunluğu;. iken (l -) ise (s = Ce.exec (t [l]) || [], d = g = ler [1], h = (lar [2] || ""). bölme ( ""). sıralama (), d) {f = w.event.special [d] || {} p = u [ d = (r? f.delegateType: f.bindType) || d] || [], s = s [2] && yeni RegExp ("(^ | \\.)" + h.join ("\\. ( ?.:.. * \\ |) ") +" (\\ | $) "), a = o = p.length;(O -) ise! C = p [o] ,! i && g == c.origType || n && n.guid == c.guid || s && s.test (c.namespace) || r && r ==!! c.selector && ( "**" == r || c.selector!) || (p.splice (o, 1), c.selector && p.delegateCount -, f.remove && f.remove.call (e, c )); bir &&! p.length && (f.teardown &&! 1! == f.teardown.call (e, h, y.handle) || w.removeEvent (e, d, y.handle), u [d ])} (d in u) yerine w.event.remove (e, d + t [l], n, r,! 0); w.isEmptyObject (u) && J.remove (e, "tutma olayları") }}, dispatch: function (e) {var t = w.event.fix (e), n, r, i, o, a, s, u = yeni Dizi (arguments.length), l = (J.get (Bu, "etkinlik") || {}) [t.type] || [], c = w.event.special [t.type] || {} (u [0] = t, n = 1 'dir; n, <arguments.length n ++) u [n] argümanlar [n] =, eğer (!! t.delegateTarget = Bu, c.preDispatch || 1 == c.preDispatch.call (bu, t)) {s = w.event.handlers.call (bu, t, l), n = 0;ise (() [++ n] = s o && t.isPropagationStopped ()!) {t.currentTarget = o.elem, r = 0;! ise ((a = o.handlers [r ++]) && t.isImmediatePropagationStopped () ) t.rnamespace &&! t.rnamespace.test (a.namespace) || (t.handleObj = a, t.data = a.data, geçersiz 0! == (i = ((w.event.special [a. origType] || {}). o.elem, u)) &&! 1 === (t.result = ı) && (t.preventDefault (), t.stopPropagation ((.apply) || a.handler ele )))} c.postDispatch döndürür && c.postDispatch.call (this, t), t.result}}, işleyiciler: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; (! u && l.nodeType && ( "click" === e.type && e.button> = 1)) if (için;! l == bu; l = l.parentNode || Bu) halinde (1 === l.nodeType && (== e.type || "klik" 0 == l.disabled!!)) {(o = [], a = {}, n = 0; n <u; n ++) geçersiz 0 === a [i = (r = t [n]). seçici + ""] && (a [i] = r.needsContext? w (i, bu) .index (l) >1: w.find (i, bu, boş [l]) uzunluk) [i] && o.push (r); o.length && s.push (. {Elem: l, yükleyiciler: o})} dönüş l = Bu, u <t.length && s.push ({elem: l, yükleyiciler: t.slice (u)}), s}, addProp: fonksiyonu (yani, t); {Object.defineProperty (w.Event.prototype, e, {numaralandırılabilir:! 0, yapılandırılabilir:! 0, get: g (t)? function () {if (this.originalEvent) return t (this.originalEvent)}: function () {if (this.originalEvent) return this.originalEvent [e]}, set: fonksiyonu (t), {Object.defineProperty (bu, örneğin, {numaralandırılabilir: 0, yapılandırılabilir: 0, yazılabilir: 0, değeri: t})}})}, tamir : function (e) {return e [w.expando]? e: yeni w.Event (e)}, özel: {load: {noBubble:! 0}, odak: {trigger: function () {if (this! == Se () && this.focus) this.focus (),! 1}, delegateType: "focusin"} 'a dönün, blur: {trigger: function () {if (this === Se () && this.blur) return this.blur () ,! 1}, delegateType: "focusOut"}, tıklatın: {tetiği:function () {if ("checkbox" === this.type && this.click && N (bu, "giriş")) this.click () ,! 1}, _ default: function (e) {return N (e.target, "a")}}, yüklemeden önce: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && ((e.originalEvent.returnValue = e.result)}}}}, w.removeEvent = işlevi (e , t, n) {e.removeEventListener && e.removeEventListener (t, n)}, w.Event = işlevi (e, t) {if (! (w))) yeni w. döndürür (e, t) ; e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 === e.returnValue? Ee: ke, this.target = e.target && 3 === e.target.nodeType e.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this.type = e, t && ağırlık .extend (bu, t); this.timeStamp = e veVe e.timeStamp || Date.now (), bu [w.expando] = 0}, w.Event.prototype = {yapıcı: w.Event, isDefaultPrevented: ke, isPropagationStopped: ke, isImmediatePropagationStopped: ke, isSimulated :! 1, engellemekDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = Ee, e &&! This.isSimulated && e.preventDefault ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagto , e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () {var e = this.originalEvent; this.isImmediatePropagationStopped = Ee, e &&! this.isSimulated && e.stopImmediateProp) .each ({altKey: 0, kabarcıklar: 0, cancelable:! 0, changedTouches: 0, ctrlKey:! 0, detay:! 0, eventPhase: 0, metakey: 0, pageX: 0, SayfaY :! 0, shiftKey: 0, görünümü:! 0 "karakter":! 0, charCode: 0, anahtar: 0, keyCode: 0, düğme: 0,! 0, pointerId:! 0, pointerType: 0, screenX: 0, screenY:! Düğmeleri:! 0, clientX: 0, clientY: 0, offsetX: 0, offsetY 0, targetTouches: 0, toElement:! 0, dokunuşlar:! 0, hangi: function (e) {var t = e.button; return null == e.ve ki && we.test (e.type)? null! = e.charCode? e.charCode: e.keyCode:! e.wich && void 0! == t && Te.test (e.type)? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.which}}, w.event.addProp), w. her bir ({MouseEnter: "fare", mouseLeave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"}, fonksiyon (örneğin, t) {w.event.special [e] = {delegateType: t, bindType : t, handle: function (e) {var n, r = bu, i = e.relatedTarget, o = e.handleObj; dönüş i && (i === r || w.contains (r, i)) || (e.type = o.origType, n = o.handler.apply (bu, bağımsız değişkenler), e.type = t) n}}}), w.fn.extend ({tarih: fonksiyonu (örneğin, t, n, r) {return De (bu, e, t, n, r)}, one: function (e, t, n, r) {return De (bu, e, t,n, r, 1)}, kapalı: işlev (e, t, n) {var r, i; eğer (e && e.preventDefault && e.handleObj), r = e.handleObj, w (e.delegateTarget) .off (r. namespace? r.origType + "." + r.namespace: r.origType, r.selector, r.handler), bu; eğer ("object" == e) e için {(e içinde) this.off (i , t, e [i]); bunu geri döndürün} return! 1! == t && "function"! = typeof t || (n = t, t = boşluk 0),! 1 === n && (n = ke) , this.each (function () {w.event.remove (this, e, n, t)})}}); var Ne = / <(?! area | br | col | embed | hr | img | input | bağlantı | meta | param) (([az] [^ \ / \ 0> \ x 20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi, Ae = / <komut | <style | <link / i, je = / \ s * checked: | / i, qe = / ^ \ s * <(([^ =] = \ s * .checked?.):!? \ [CDATA \ [|işleyici), bu; if ("object" == e) e) {için (e in i) this.off (i, t, e [i]); bunu geri döndürün} return! 1! == t && "function"! = typeof t || (n = t, t = boş 0),! 1 === n && (n = ke), this.each (function () {w.event.remove (this, e, n, t) })}}); var Ne = / <(?! area | br | col | embed | hr | img | input | link | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi, Ae = / <script | <style | <link / i, je = / \ s * checked (?: [^ =] | .!? | \ [CDATA \ [: = \ s * .checked) / i, qe = / ^ \ * <(sişleyici), bu; if ("object" == e) e) {için (e in i) this.off (i, t, e [i]); bunu geri döndürün} return! 1! == t && "function"! = typeof t || (n = t, t = boş 0),! 1 === n && (n = ke), this.each (function () {w.event.remove (this, e, n, t) })}}); var Ne = / <(?! area | br | col | embed | hr | img | input | link | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi, Ae = / <script | <style | <link / i, je = / \ s * checked (?: [^ =] | .!? | \ [CDATA \ [: = \ s * .checked) / i, qe = / ^ \ * <(s.!? | \ [CDATA \ [: işaretli) / i, qe = / ^ \ * <(s.!? | \ [CDATA \ [: işaretli) / i, qe = / ^ \ * <(s-) | (?: \] \] | -)> \ s * $ / g; işlevi Le (e, t) {, N (e, "tablo") döndürür && N (11! == t.nodeType? t: t.firstChild, "tr")? w (e) .çocuk ("tbody") [0] || e: e} işlevi He (e) {return e.type = (null! == e.getAttribute ("type")) + "/" + e.type, e} işlevi Oe (e) {return "true /" === (e.type || ""). dilim (0,5)? e. type = e.type.slice (5): e.removeAttribute ("type"), e} işlevi Pe (e, t) {var n, r, i, o, a, s, u, l; === t.nodeType) {if (J.hasData (e) && (o = J.access (e), a = J.set (t, o), l = o.events))) {sil a.handle , a.events = {}; (i in) için (n = 0, r = l [i]. uzunluk; n <r; n ++) w.event.add (t, i, l [i] [ n])} K.hasData (e) && (s = K. erişimi (e), u = w.extend ({}, s), K.set (t, u))}} işlev Me (e, t ) {var n = t.nodeName.toLowerCase (); "input" === n && pe.test (e.type)? t.checked = e.checked: "input"! == n && "textarea"!== n || (t.defaultValue = e.defaultValue)} işlevi Re (e, t, n, r) {t = a.apply ([], t); var i, o, s, u, l, c, f = 0, p = e. uzunluk, d = p-1, y = t [0], v = g (y); eğer (v || p> 1 && "string" == yazın ve! h. checkClone && je.test (y)), e.each işlevini döndürür (işlev (i) {var o = e.eq (i); v && (t [0] = y.call (bu, i, o.html ())), Re (o, t, n, r)};) (s && (i = xe (t, e [0] .ownerDocument, 1, e, r) o = i.firstChild ise, i = 1 ===. childNodes.length && (u = (s = w.map (ki (i "komut"), O,)) uzunluğu (i = O), O || r)) {; f. <s: f ++) l = i, F! == d && (l = w.clone (l, l! 0! 0) u && w.merge (s, ye (l, l "komut"))), n.call (e [f] l f) f <u;, eğer, f = 0 (u) (c = s [s.length-1] .ownerDocument, w.map (s, Oe için), f ++), I = s [F] o .test (l.type || "") &&! J.access (l, l "globalEval") && w.contains (c, l) && (l.src && "modül"! == (l.type || "" ) .toLowerCase () 'w._evalUrl && w._evalUrl (l.src): m (l.textContent.replace (qe, ""), c, l))} return e} işlevi Ie (e, t, n) {için (var r, i = t ? w.filter (t, e) e, o = 0, boş = (r = i [o]); o ++) n || 1 == r.nodeType || w.cleanData (ki (r)! ), r.parentNode && (n && w.contains (r.ownerDocument, r) && ve (ye (r, "script")), r.parentNode.removeChild (r)); e} w.extend ({htmlPrefilter: function ( e) {return e.replace (Ne, "<$ 1> </ $ 2>")}, klon: işlev (e, t, n) {var r, i, o, a, s = e.cloneNode (! 0 ) u = w.contains (e.ownerDocument, e)! if ((|| 1 h.noCloneChecked == e.nodeType && 11 == e.nodeType || w.isXMLDoc (e))), (a = ye (ler) i, r = 0, i = (o = ki (e)) uzunluğu;. r <i, r ++), o Me ([r], bir [d]), eğer (t) ise (n) (o = o || ye (e), a = a || ye (ler), r = 0, i = o.length, r, <i, r ++), Pe (o [d], bir [d]) ; else Pe (e, s); return (a = ye (s, "script")). uzunluk> 0 && ve (a,! u && ye (e, "script")), s}, cleanData:işlev (e) {için (var t, n, r, i = w.event.special, o = 0; boşluk 0! == (n = e [o]); o ++) eğer (Y (n)) { if (t = n [J.expando]) {((t.events) 'in (t.events içinde) i [r] a w.event.remove (n, r) için: w.removeEvent (n, r, t.handle); n [J.expando] = geçersiz 0} n [K.expando] && (n [K.expando] = geçersiz 0)}}}), w.fn.extend ({detach: function (e) ) {return Ie (this, e,! 0)}, remove: function (e) {return Ie (this, e)}, text: function (e) {return z (this, function (e) {return void 0 === e w.text (bu):.!! this.empty () her biri (fonksiyonu () {1 == this.nodeType && 11 == this.nodeType && 9 == this.nodeType || (this.textContent = e)})}, null, e, arguments.length)}, append: function () {return Re (this, argümanlar, function (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || Le (this, e) .appendChild (e)})}, prepend: function () {return Re (this, argümanlar, function (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Le (this, e);t.insertBefore (e, t.firstChild)}})}, önce: function () {return Re (this, argümanlar, function (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, sonra : function () {return Re (bu, argümanlar, işlev (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, empty: function () {for (var e, t = 0; null! = (e = this [t]); t ++) 1 === e.nodeType && (w.cleanData (ye (e,! 1)), e.textContent = ""); buna dönün}, klon: function (e, t) {return e = null! = e && e, t = null == t? e: t, this.map (function () {return w.clone (this, e, t)})}, html: işlevi (e) {return z (bu, işlev (e) {var t = this [0] || {}, n = 0, r = this.length; eğer (void 0 === e && 1 === t. nodeType) t.innerHTML döndürür, eğer ("string" == e &&! Ae.test (e) &&! ge [(de.exec (e) || ["", ""]) [1] .toLowerCase ( )]) {e = w.htmlPrefilter (e) {(deneyin n <r;N ++), 1 === (.! t = bu [n] || {}) noteType && (w.cleanData (ki (t, 1)), t.innerHTML = e) t = 0} yakalamak (e) { }} t && this.empty (). append (e)}, null, e, arguments.length)}, replaceWith: function () {var e = []; return Re (this, arguments, function (t) {var n = this.parentNode; w.inArray (bu, e) <0 && (w.cleanData (ki (bu)) n && n.replaceChild (t, bu))}, e)}}), w.each ({appendTo: , prependTo "ekleme": "başına", insertBefore: InsertAfter "daha önce": "sonra" replaceAll: "replaceWith"}, fonksiyon (örn, t) {w.fn [e] = fonksiyon (e) {için ( var n, r = [], i = w (e), o = i.lendth-1, a = 0; a <= o; a ++) n = a === o? this: this.clone (! 0 ), w (i [a]) [t] (n), s.apply (r, n.get ()); şunu döndürün: this.pushStack (r)}}); var We = new RegExp ("^ (" + re + ") (?! px) [az%] + $", "i"), $ e = işlev (t) {var n = t.ownerDocument.defaultView; return n && n.opener || (n = e) n.getComputedStyle (t)}, Be = yeni RegExp (oe.join ("|"), "i") ;! function () {function t () {if (c) {l.style.cssText = "position: absolute , sol: -11111px; genişliği: 60 piksel, kenar üstü: 1 piksel; doldurma: 0; sınır: 0" , c.style.cssText = "pozisyonu: göreceli; görüntü: blok, kutu boyutlandırma: sınır-kutu; taşması: scroll; marj: auto; border: 1px; dolgu: 1px; genişlik:% 60; üst:% 1 ", be.appendChild (l) .appendChild (c); var t = e.getComputedStyle (c); i =" % 1 "! == t.top u 12 === n (t.marginLeft) =, = c.style.right" % 60", SO, = 36 36 === n (t.right) = === n (t.width), c.style.position = "mutlak", a = 36 === c.offsetWidth || "absolute", be.removeChild (l), c = null}} işlev n ( e) {return Math.round (parseFloat (e))} var ı, o, a, s, u, l = r.createElement ("div"), c = r.createElement ("div"); c.style && (c.style.backgroundClip = "content-box", c.cloneNode (! 0) .Style.backgroundClip = "", h.clearCloneStyle = "content-box" === c.style.backgroundClip, w.extend (h, {boxSizingReliable: function () {return t (), o}, pixelBoxStyles: function () { return t (), s}, pixelPosition: function () {return t (), i}, ReliableMarginLeft: function () {return t (), u}, scrollboxSize: function () {return t (), a}} ))} (); işlevi Fe (e, t, n) {var r, i, o, a, s = e.style; return (n = n || $ e (e)) && (""! = = (a = n.getPropertyValue (t) || n [t]) || w.contains (e.ownerDocument e) || (a = w.style (yani, t)) ,! h.pixelBoxStyles () && We.test (a) '&& a = n = s.maxWidth, s.minWidth = s.maxWidth = s.width = bir o Be.test (t) && (r = s.width, i = s.minWidth,. genişlik, s.width = r, s.minWidth = i, s.maxWidth = o)), geçersiz 0! == a? a + "": a} function _e (e, t) {return {get: function () {if (! e ()) return (this.get = t) .apply (this, argümanlar); this.get yazın}}} var ze = / ^ (none | table (?! - c [ea]). +) / Xe'nin = / ^ - /,Ue = {pozisyonu: "mutlak", görüş:, ekran "gizli": "blok"} = {: "0", fontWeight: harf "400"} Ve, Ge = [ "Webkit'teki", "Moz"," ms "], Ye = r.createElement (" div "). tarzı; işlevi Qe (e) {eğer (Ye'de e) e döndürür; var t = e [0] .toUpperCase () + e.slice (1) , n = Ge.length; (n -) eğer ((e) Ge (n] + t) Ye) 'e dönerse e} işlevi Je (e) {var t = w.cssProps [e]; return t | | (t = w.cssProps [e] = Qe (e) || e), t} işlevi Ke (e, t, n) {var r = ie.exec (t); return r? Math.max (0 , r [2] - (n || 0)) + (r [3] || "px"): t} işlevi Ze (e, t, n, r, i, o) {var a = "width" === t? 1: 0, s = 0, u = 0; eğer (n === (r? "kenarlık": "içerik")) 0 döndürürse, (; a <4; a + = 2) " marjı "=== n && (u + = w.css (e, n + oe [a] ,! 0, i)), ki burada r (" içerik "=== n && (u = w.css (e" dolgu "+ oE [a] ,! 0, i))," sınır "! == n && (u-w =.CSS (yani, "sınır" + oe [a] + "genişliği",! 0, i))) :(, u + = w.css (yani, "doldurma" + oe [a] ,! 0, i)" doldurma "!? == n, u + = w.css (yani," sınır "+ oe [a] +" genişliği", 0, i!) s + = w.css (yani, "sınır" + oe [a] + "genişliği", 0, i));! geri r && o> = 0 && (u + = Math.max (0, math.ceil (e [+ t [0] .toUpperCase () + t.slice "ofset" (! 1)] - ous-.5))), u} işlevi et (e, t, n) {var r = $ e (e), i = Fe (e, t, r), o = "sınır kutusu "=== w.css (e," boxSizing ",! 1, r), a = o; if (We.test (i)) {if (! n) döndürün i; i =" auto "} = bir && (h.boxSizingReliable () || i === e.style [t]), ( "otomatik" === i ||! parseFloat, (i) && "satır" === w.css (yani, "ekran",! 1, r)) && (i = e [ "ofset" + t [0] .toUpperCase () + t.slice (1)], a =! 0), (i = parseFloat: (i) || 0) + Ze (e, t, n || (o "sınır": "içerik"), a, r, ı) + "piksel"} w.extend ({cssHooks: {opacity: {get: function (e, t) {eğer (t) {var n = Fe (e, "opacity"); "" === n? "1" döndürün: n}}}} cssNumber: {animationIterationCount: 0, columnCount: 0, fillOpacity: 0, flexGrow: 0, flexShrink: 0, fontWeight: 0, lineHeight: 0, donukluk: 0, sipariş :! 0, yetim: 0, dul: 0, zIndex: 0, zum: 0}, cssProps: {} stili:! fonksiyonu (yani, t, n, r) {(e ise && 3 == e .nodeType && 8! == e.nodeType && e.style) {var i, o, a, s = G (t), u = Xe.test (t), l = e.style; if (u || (t = Je) (s)), a = w.cssHooks [t] || w.cssHooks [s], geçersiz 0 === n) bir && "get" döndürerek && void 0! == (i = a.get (e ,! 1, r))? İ: l [t]; "string" == (o = n = typeof) && (i = ie.exec (n)) && i [1] && (n = ue (e, t, i ), o = "sayı"), boş = n && n === n && ( "sayı" === o && (n + i = && i [3] || (w.cssNumber [s] "": "piksel")!) h.clearCloneStyle || ""! == n || 0! == t.indexOf ("background") || (l [t] = "miras"), && void 0 === (n = a .set (e, n, r)) || (u? l.setProperty (t, n): l [t] = n))}}, css: function (e, t, n, r) {var i , o, a, s = G (t); döndür Xe.test (t) || (t = Je (s)), (a = w.cssHooks [t] || w.cssHooks [s]) && " "bir && (i = a.get (e,! 0, n)) 'da, void 0 === i && (i = Fe (e, t, r))," normal "=== Ve & ( = === [t]) "" Ve n || n (o = parseFloat (i) ,! 0 === n || isFinite (o) o-|| 0:? ı) i}}) , w.each ([ "yükseklik", "genişlik"], fonksiyon (örn, t) {w.cssHooks [t] = {olsun: eğer fonksiyon (örn, n, r) {(n) geri ze.test (w.css (e, "ekran")) || e.getClientRects (). uzunluk && e.getBoundingClientRect (). width? et (e, t, r): se (e, Ue, function () {return et ( e, t, r)})}, set: function (e, n, r) {var i, o = $ e (e), a = "border-box" === w.css (e, "boxSizing ",! 1, o), s = r && Ze (e, t, r, a, o); döndürerek && h.scrollboxSize () === o.position && (s- = Math.ceil (e [" ofset "+) t [0] .toUpperCase () + t.slice (1)] - parseFloat (o [t]) - Ze (e, t, "sınır", 1, o!) -. 5)), s && (i = ie.exec (n)) && "piksel"! == (i [3] || "piksel") && (e.style [t] = n, n = w.css (yani, t)), Ke ( e, n, s)}}}), w.cssHooks.marginLeft = _e (h.reliableMarginLeft, fonksiyon (örneğin, t) {halinde (±) dönüş (parseFloat (Fe (yani, "marginLeft")) || e .getBoundingClientRect (). left-se (e, {marginLeft: 0}, function () {return e.getBoundingClientRect (). left})) + "px"}), w.each ({margin: "", dolgu maddesi : "", sınır: "Genişlik"}, işlev (e, t) {w.cssHooks [e + t] = {genişlet: işlev (n) {için (var r = 0, i = {}, o = " string "== typeof n? n.split (" "): [n]; r <4; r ++) i [e + oe [r] + t] = o [r] || o [r-2] | | o [0]; return i}}, "marj"!== e && (w.cssHooks [e + t] .set = Ke)}), w.fn.extend ({css: işlevi (e, t) {return z (bu, işlev (e, t, n) { var r, i, o = {}, a = 0; eğer (Array.isArray (t)) {için (r = $ e (e) için, i = t.length; a <i; a ++) o [t [ a]] = w.css (e, t [a] ,! 1, r); return o} dönüş void 0! == n? w.style (e, t, n): w.css (e, t )}, e, t, arguments.length> 1)}}); tt işlevi (e, t, n, r, i) {return yeni tt.prototype.init (e, t, n, r, i)} w.Tween = tt, tt.prototype = {yapıcı: tt init: fonksiyonu (e, t, n, r, ı, o) {this.elem = e, this.prop = n, this.easing = i | | w.easing._default, this.options = t, this.start = this.now = this.cur (), this.end = r this.unit = o || (w.cssNumber [n] ""? : "px")}, cur: function () {var e = tt.propHooks [this.prop]; dönüş e && e.get? e.get (this): tt.propHooks._default.get (this)}, çalıştırın : function (e) {var t, n = tt.propHooks [this.prop]; şunu this.options.duration? this.pos = t = w.easing [this.easing] (e, this.options.duration * e, 0,1, this.options.süresi): this.pos = t = e * t + this.start, this.options.step && this.options.step.call (this.elem, this.now) = (this.end-this.start this.now bu), n && n.set n.set (bu): tt.propHooks._default.set (bu), bu}} tt.prototype.init.prototype = tt.prototype, tt.propHooks = {_ varsayılan: { get: function (e) {var t; dönüş 1! == e.elem.nodeType || null! = e.elem [e.prop] && null == e.elem.style [e.prop]? e.elem [e.prop] :( t = w.css (e.elem, e.prop, "")) && "otomatik" == t t:!? 0}, set: fonksiyonu (e) {w.fx. ? adım [e.prop] w.fx.step [e.prop] (e): 1 == e.elem.nodeType || boş == e.elem.style [w.cssProps [e.prop]]! ! && w.cssHooks [e.prop] e.elem [e.prop] = e.now: w.style (e.elem, e.prop, e.now + e.unit)}}}, tt. propHooks.scrollTop = tt.propHooks.scrollLeft = {grubu: fonksiyonu (e) {e.elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}} w.easing = {doğrusal : function (e) {dönüş e}, dönüş:fonksiyonu (e) {return.5-Math.cos (e * Math.PI) / 2} _ varsayılan: "salınım"}, w.fx = tt.prototype.init, w.fx.step = {}; var nt, rt, o = / ^ (?: toggle | show | hide) $ /, ot = / queueHooks $ /; () işlevinde () {rt && (! 1 === r.hidden && e.requestAnimationFrame? ): e.setTimeout (at, w.fx.interval), w.fx.tick ())} işlev st () {return e.setTimeout (işlev () {nt = boşluk 0}), nt = Tarih.now ()} fonksiyonu ut (e, t) {var n, r = 0, i = {yükseklik: e}; (t = t? 1: 0; r <4; r + = 2-t) i ["marjı "+ (n = oe [r])] = i [" dolgu "+ n] = e; dönüş t && (i.opacity = i.width = e), i} işlevi lt (e, t, n) {için (var r, i = (pt.tweeners [t] || []). concat (pt.tweeners ["*"]), o = 0, a = i.length; o <a; o ++) ise (r = i [o] .call (n, t, e)) r} fonksiyonunu döndürür ct (e, t, n) {var r, i, o, a, s, u, l, c, f = "genişlik" t || "height" in t, p = this, d = {}, h = e.style, g = e.nodeType && ae (e), y = J.get (e, "fxshow"); n.|| (NULL == (a = w._queueHooks (yani, "fx")). Unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = fonksiyonu () {a kuyruk. . unqueued || s ()}), ++ p.always (fonksiyonu () {p.always (fonksiyonu () {a.unqueued a.unqueued -, w.queue (e "fx") uzunluğu || bir .empty.fire ()})})); (r in t) için (i = t [r], it.test (i)) {if (silme t [r], o = o || "toggle "=== i, i === (g?" hide ":" show ")) {if (" show "! == i ||! y || void 0 === y [r]) devam; g =! 0} d [d] = y && y [d] || w.style (e, r)} halinde ((u =! w.isEmptyObject (t)) ||! w.isEmptyObject (d)) {f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], boş == (l = y && y.display) && (l = J.get (yani, "ekran")) , "yok" === (c = w.css (yani, "ekran")) && (l c = l: (fe ([e] ,! 0), I = e.style.display || l , c = w.css (yani, "ekran"), fe ([e]))), ( "satır içi" === c ||"içi blok "=== c && boş! = l) &&" yok "=== w.css (yani," yüzen ") && (u || (p.done (fonksiyonu () {h.display = l}) null == l && (c = h.display, l = "yok" === c "?": c)), h.display = "satır içi blok")), n.overflow && (h.overflow =" "gizli, p.always (fonksiyonu () {h.overflow = n.overflow [0], h.overflowX = n.overflow [1], h.overflowY = n.overflow [2]})), u =! 1; (d in r) u || (y? "Y && (g = y.hidden) içinde gizli": y = J.access (e, "fxshow", {display: l}), o & & (y. gizli =! g), g && fe ([e] ,! 0), p.done (function () {g || fe ([e]), J.remove (e, "fxshow"); ) w.style (e, r, d [r])})), u = lt (g? y [r]: 0, r, p), r in y || (y [r] = u.start , g && (u.end = u.start, u.start = 0))}} fonksiyonu ft (e, t) {var n, r, i, o, a; için (e in), (r = G (n), i = t [r] o = e [n], Array.isArray (o) && (i = o [1] o = e [n] = o [0]) n! == r &&(e [r] = o, e [n]) 'i silin, (a = w.cssHooks [r]) && "genişlet" a) {o = a.expand (o), e [r]; n in o) n in e || (e [n] = o [n], t [n] = i)} else t [r] = i} fonksiyon pt (e, t, n) {var r, i , o = 0, a = pt.prefilters.length, s = w.Deferred (). always (function () {delete u.elem}), u = function () {if (i)! var t = nt || st (), n = Math.max (0, l.startTime + l.duration-t), r = 1- (n / l.duration || 0), o = 0, a = l.tweens.length; o <a; o ++) l.tweens [o] .run (r); s.notifyWith (e, [l, r, n]), r <1 && a? n: (a || s.notifyWith (e, [l, 1,0]), s.resolveWith (e [l]) ,! 1)}, I = s.promise ({elem: e, sahne: w.extend ({} , t); seçmesi: w.extend (0,! {specialEasing: {}, hareket hızı: w.easing._default}, n) originalProperties: t, originalOptions: n, startTime: st () || nt süresi: n.duration, tweens: [], createTween: function (t, n) {var r = w.Tween (e, l.opts, t, n, l.opts.specialEasing [t] || l.opts.easing ); l.tweens.push (r), r}, stop: function (t) {var n = 0, r = t? l döndür.tweens.length: 0; (i) bunu döndürürse; (i =! 0; n <r; n ++) 1. tweens [n] .run (1) için, t? (s.notifyWith (e, [l) , 1,0]), s.resolveWith (e [l, t])): s.rejectWith (e, [l, t]), bu}}), c = l.props; için (ft (c , l.opts.specialEasing); o <a; o ++) eğer (r = pt.prefilters [o] .call (l, e, c, l.opts)) g (r.stop) && (w._queueHooks) döndürür (l.elem, l.opts.queue) .stop = r.stop.bind (r)), r; w.map (c, lt, l), g (l.opts.start) && l.opts. start.call (e, l) l.progress (l.opts.progress) .done (l.opts.done, l.opts.complete) .fail (l.opts.fail) .always (l.opts. her zaman), w.fx.timer (w.extend (u, {elem: e, Anim: l, kuyruğu: l.opts.queue})), I} w.Animation = w.extend (pt, {tweeners: {"*": [fonksiyon (e, t) {var n = this.createTween (e, t); return ue (n.elem, e, yani .exec (t), n), n}]}, ara doldurucu : işlev (e, t) {g (e)? (t = e, e = ["*"]): e = e.match (M); için (var n, r = 0, i = e. , r <i, r ++), n = e [d], pt.tweeners [n] = pt.tweeners [n] || [], pt.tweeners [n].unshift (t)}, ön filtreler: [ct], ön-filtre: fonksiyonu (yani, t) {t pt.prefilters.unshift (e) pt.prefilters.push (e)}}), w.speed = fonksiyonu ( e, t, n) {var r = e && "nesne" == e-w.extend ({}, e): {complete: n ||! n && t || g (e) && e, süre: e, hareket hızı : n && t || t &&! g (t) && t}; döndürün w.fx.off?r.duration=0:"number"!=typeof r.duration && (w.fx.speeds? r.duration = r.duration = w.fx.speeds [r.duration]:! r.duration = w.fx.speeds._default), boş = r.queue && 0 == r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = fonksiyonu () {gr (r.old) && r.old.call (bu), r.queue && w.dequeue (bu, r.queue)}, r}, w. fn.extend ({fadeTo: function (e, t, n, r) {this.filter (ae) .css ("opacity", 0) .show (). end (). animate ({opacity: t} , e, n, r)}, animate: function (e, t, n, r) {var i = w.isEmptyObject (e), o = w.speed (t, n, r),a = function () {var t = pt (bu, w.extend ({}, e), o); (i || J.get (bu, "bitir")) && t.stop (! 0)}; dönüş a.finish = a, i ||! 1 === o.queue? this.each (a): this.queue (o.queue, a)}, stop: function (e, t, n) {var r = fonksiyon (e) {var t = e.stop; e.stop sil, t (n)}; "string" döndür! = = e && (n = t, t = e, e = geçersiz 0), t &! 1! == e && this.queue (e || "fx", []), this.each (function () {var t =! 0, i = null! = E && e + "queueHooks", o = w.timers, a = J.get (this); eğer (i) a [i] && a [i] .stop && r (a [i]); aksi takdirde (i) a [i] && a [i] .stop && ot.test (i) ) && r: (a [i]); (i = o.length i -;!! o) [i] .elem == null || = e && o [i] .queue == e || ( ! o [i] .anim.stop (n) t = 1, o.splice (i, 1)) ;! t && n || w.dequeue (bu, e)})}, kaplama: fonksiyonu (e) { dönüş! 1! == e && (e = e || "fx"), this.each (function () {var t, n = J.get (bu), r = n [e + "kuyruk "], i = n '[e +" queueHooks "] o = w.timers, a = r r.length:! 0 (n.finish için = 0, w.queue (bu, örneğin, []) i && i.stop && i.stop.call (bu, 0!) t = o.length t -;) [t] .elem o === o Bu && [t], .queue === e && (o [t] .anim.stop (! 0), o.splice (t, 1)); (t = 0, t <a; t ++) r [t] && r [t] .finish && r [t], .finish.call (bu ); n.finish})}}), w.each (["toggle", "show", "hide"], işlev (e, t) {var n = w.fn [t]; w.fn [t] = fonksiyon (e, r, i) {return null == e || "boolean" == e? n.apply (this, argümanlar): this.animate (ut (t,! 0), e , r i)}}), w.each ({slideDown: ut ( "") için, slideUp: ut ( "gizlemek"), slideToggle: ut ( "geçiş"), fadeIn: {opaklık: "göster"} , fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, işlev (e, t) {w.fn [e] = işlev (e, n, r) {return this.animate ( t, e, n, r)}}), ağ.zamanlayıcılar = [], w.fx.tick = function () {varis e, t = 0, n = w.timers; for (nt = Date.now (); t <n.length; t ++) (e = n [t]) () || n [t]! == e || n.splice (t -, 1); n.length || w.fx.stop (), nt = boşluk 0}, w. fx.timer = fonksiyonu (e) {w.timers.push (e) w.fx.start ()}, w.fx.interval = 13, w.fx.start = fonksiyonu () {oda sıcaklığına || (oda sıcaklığı ! = 0, A ())}, w.fx.stop = fonksiyonu () {r, = null}, w.fx.speeds = {yavaş: hızlı 600, 200, _default: 400}, w.fn.delay = function (t, n) {return t = w.fx? w.fx.speeds [t] || t: t, n = n || "fx", this.queue (n, function (n, r) {var i = e.setTimeout (n, t); r.stop = function () {e.clearTimeout (i)}})}, function () {var e = r.createElement ("input"), t = . r.createElement ( "select") appendChild (r.createElement ( "seçenek"));! e.type = "checkbox", h.checkOn = "" == e.value, h.optSelected = t.selected, (e = r.createElement ( "giriş")). değeri = "t" e.type = "telsiz" h.radioValue = "t" === e.değer} (); var dt, ht = w.expr.attrHandle; w.fn.extend ({attr: function (e, t) {return z (bu, w.attr, e, t, arguments.length> 1 )}, removeAttr: function (e) {return this.each (function () {) {w.removeAttr (this, e)})}}), w.extend ({attr: function (e, t, n) {var r, i, o = e.nodeType; eğer (3! == o && 8! == o && 2! == o) "undefined" == yazdığınızda e.getAttribute? w.prop (e, t, n) :( 1 === && w.isXMLDoc (e) || (i = w.attrHooks [t.toLowerCase ()] || (w.expr.match.bool.test (t)? dt: geçersiz 0)), geçersiz 0! == n? null === n? void w.removeAttr (e, t): i && void 0 'da "& set"! == (r = i.set (e, n, t))? r: (e. setAttribute (t, n + ""), n): i & & null'da i & & "olsun" == (r = i.get (e, t))? r: null == (r = w.find.attr (e, t))? void 0: r)}, attrHooks: {type: {set: function (e, t) {eğer (! h.radioValue && "radio" === t && N (e, "input"))) {var n = e.değer, dönüş e.setAttribute ("type", t), n && (e.value = n), t}}}}, removeAttr: function (e, t) {var n, r = 0, i = t & t.match (M); fonksiyonu (e, t, n) {dönüş 1 === t: (n = i [r ++]) e.removeAttribute (n)}}), dt = {grubu ise, (i 1 === e.nodeType &&)!? w.removeAttr (e, n): e.setAttribute (n, n), n}} w.each (w.expr.match.bool.source.match (/ \ + / g ağırlık), fonksiyon (örneğin, t ) {var n = ht [t] || w.find.attr; ht [t] = fonksiyon (e, t, r) {var i, o, a = t.toLowerCase (); return r || (o = ht [a], ht [a] = i, i = null! = n (e, t, r) a: null, ht [a] = o), i}}); var gt = / ^ ( ?: input | select | textarea | button) $ / i, yt = / ^ (?: a | area) $ / i; w.fn.extend ({prop: function (e, t) {return z (this, w.prop, e, t, arguments.length> 1)}, removeProp: function (e) {return this.each (function () {bunu sil [w.propFix [e] || e]})}}) , w.extend ({prop: function (e, t, n) {var r, i, o = e.nodeType; eğer (3! == o && 8! == o && 2! == o) 1 === o &&w döndürür. .isXMLDoc (e) '|| (t = w.propFix [t] || t, J = w.propHooks [t]), void 0! == n? i & & "void" in "& # void 0! == (r = i.set (e, n, t))? r: e [t] = n: i & &" "içinde & null! == (r = i.get (e, t))? r: e [t]}, propHooks: {tabIndex: {get: function (e) {var t = w.find.attr (e , "tabindex"); dönüş t? parseInt (t, 10): gt.test (e.nodeName) || yt.test (e.nodeName) && e.href? 0: -1}}}, propFix: {" ":" htmlFor "için," class ":" className "}}), h.optSelected || (w.propHooks.selected = {get: function (e) {var t = e.parentNode; return t && t.parentNode && t. parentNode.selectedIndex, null}, set: function (e) {var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)}}), w.each (["tabIndex", "readOnly) " "maxLength", "cellspacing", "cellpadding", "rowSpan", "colspan","useMap "," frameBorder "," contentEditable "], function () {w.propFix [this.toLowerCase ()] = this}); function vt (e) {return (e.match (M) || []) .join ("")} işlevi mt (e) {return e.getAttribute && e.getAttribute ("class") || ""} işlevi xt (e) {return Array.isArray (e)? e: "string" == typeof e? e.match (M) || []: []} w.fn.extend ({addClass: function (e) {var t, n, r, i, o, a, s, u = 0; if (g (e)) şunu döndürür. (işte (t) {w (bu) .addClass (e.call (bu, t, mt (bu))))}); eğer ((t = xt (e)) ) .length) iken (n = bu [u ++]) eğer (i = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; = t [a ++]) r.indexOf ("" + o + "") <0 && (r + = o + ""); i! == (s = vt (r)) && n.setAttribute ("class", s)} bunu geri döndür}, removeClass: function (e) {var t, n, r, i, o, a, s, u = 0; if (g (e)) eğer this.each (function (t) {w (this) ).removeClass (e.call (this, t, mt (bu))))}); if (! arguments.length) this.attr ("class", ""); eğer ((t = xt (e))) döndür. uzunluk) iken (n = bu [u ++]) ise ((i = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; [a ++]) iken (r.indexOf ("" + o + "")> - 1) r = r.replace ("" + o + "", ""); i! == (s = vt (r)) && n.setAttribute ("class", s)} bunu döndürün}, toggleClass: function (e, t) {var n = typeof e, r = "string" === n || Array.isArray (e); return " boolean "== t &&d? t? this.addClass (e): this.removeClass (e): g (e)? this.each (işlev (n) {w (bu) .toggleClass (e.call (bu, n, mt (bu), t), t)}): this.each (function () {var t, i, o, a; eğer (r) {i = 0, o = w (bu), a = xt (e); süre (t = a [i ++]) o.hasClass (t)? o.removeClass (t): o.addClass (t)} else void 0! == e && "boolean"! == n | | ((t = mt (Bu))& J.set (bu, "__ className __", t), this.setAttribute && this.setAttribute ( "class" t || 1 === e "!?": J.get (bu, "__ className __") || "" ))})}, hasClass: function (e) {var t, n, r = 0; t = "" + e + ""; olurken (n = bu [r ++]) eğer (1 === n.nodeType && ( "" + vt (mt (n)) + "") .indexOf (t)> - 1) geri dönüş! 0; geri dönüş! 1}}); var bt = / \ r / g; w.fn.extend ({ val: function (e) {var t, n, r, i = this [0]; {if (arguments.length), r = g (e) döndürür, this.each (function (n) {var i; 1 = == this.nodeType && (null == (i = r? e.call (bu, n, w (bu) .val ()): e)? i = "": "sayı" == typeof i? i + = "": Array.isArray (i) && (i = w.map (i, function (e) {return null == e? "": E + ""})), (t = w.valHooks [this.type ] || w.valHooks [this.nodeName.toLowerCase ()]) && "set" içinde & & void 0! == t.set (this, i, "değeri ") || (this.value = i))}); (i) geri dönüşü (t = w.valHooks [i.type] || w.valHooks [i.nodeName.toLowerCase ()]) &&" olsun "t && void 0! == (n = t.get (i," değer "))? n:" string "== typeof (n = i.value)? n.replace (bt," "): null = = n? "": n}}}), w.extend ({valHooks: {option: {get: function (e) {var t = w.find.attr (e, "değer"); return null! = t? t: vt (w.text (e))}}, şunu seçin: {get: function (e) {var t, n, r, i = e.options, o = e.selectedIndex, a = "select- bir "=== e.type, s = boş: [], u = + o'nun 1:? i.length; (r = o <0 u: a: o? 0; r <u; r ++) halinde (((n = i [r]). seçilen || r === o) &&! n.disabled && (! n.parentNode.disabled ||! N (n.parentNode, "OPTGROUP"))) {eğer (t = w (n) .val (), a) geri dönüş t; s.push (t)} dönüş s}, set: function (e, t) {var n, r, i = e.options, o = w.makeArray (t), a = i.length;. gelmektedir (-) ((r = i: [a]), seçilen = w.inArray (w.valHooks.option.get (r) o) >-1) && (n =! 0); return n || (e.selectedIndex = -1), o}}}}), w.each (["radio", "checkbox"], function () {w .valHooks [this] = {set: function (e, t) {if (Array.isArray (t)) döndürür e.checked = w.inArray (w (e) .val (), t)> - 1}} , h.checkOn || (w.valHooks [this] .get = function (e) {return null === e.getAttribute ("value")? "on": e.value})}), h.focusin = "onfocusin" e; var wt = / ^ (?: focusinfocus | focusoutblur) $ /, Tt = işlevi (e) {e.stopPropagation ()}; w.extend (w.event, {trigger: function (t , n, i, o) {var a, s, u, l, c, p, d, h, v = [i || r], m = f.call (t, "type")? t.tipi : t, x = f.call (t, "ad") t.namespace.split? ( ""): [], eğer (s = h = u = i = i || r, 3 == ı .nodeType && 8 == i.nodeType && wt.test (m + w.event.triggered) && (m.indexOf ()>! " "- 1 && (m = (x = m.split ())".". shift () x.sort ()), c = m.indexOf ( ":") <0 && "on" + m, t = t [w.expando]? T: yeni w.Event (m, "nesne" == t && t yazın), t.isTrigger = o? 2: 3, t.namespace = x. join ("."), t.rnamespace = t.namespace? new RegExp ("(^ | \\.)" + x.join ("\\. (?:. * \\.)))" " (\\. | $) "): null, t.result = geçersiz 0, t.target || (t.target = i), n = null == n? [t]: w.makeArray (n, [ t]), d = w.event.special [m] || {} o ||! d.trigger ||! 1! == d.trigger.apply (i, n))) {halinde (! o && ! d.noBubble && y (i)) {(l = d.delegateType || m, wt.test (l + m) || (s = s.parentNode) için;! s s = s.parentNode) s. itme (lar) u = s; u === (i.ownerDocument || r) && v.push (u.defaultView || u.parentWindow || e)} ve a = 0, ((s = T [bir süre ++ ]) && t.isPropagationStopped ()) h = s, t.type = a> 1: l? d.bindType || m, (p = (J.get (s, "etkinlik")! || {}) [t.type] && J.get (s, "kolu"))) && p.apply (s, n (p = c && kullanıcının [c]) && p.apply &&Y (s) && (t.result = p.apply (s, n) ,! 1 === t.result && t.preventDefault ()); return t.type = m, o || t.isDefaultPrevented () || d._default &&! 1! == d._default.apply (v.pop (), n) ||! E (i) '|| c && gr (i [m]) &&! y (i) && ((u = ı [c]) && (i [c] = NULL) w.event.triggered = m t.isPropagationStopped () && h.addEventListener (m, tt), i: [A] (), t.isPropagationStopped () && h. removeEventListener (m, Tt), w.event.triggered = void 0, u && (i [c] = u)), t.result}}, simule et: işlev (e, t, n) {var r = w.extend (yeni w.Event, n, {type: e, isSimulated:! 0}); w.event.trigger (r, null, t)}}), w.fn.extend ({trigger: function (e, t ) {return this.each (function () {w.event.trigger (e, t, this)})}, triggerHandler: function (e, t) {var n = this [0]; eğer (n) w .event.trigger (e, t, n,! 0)}}), h.focusin || w.each ({focus: "focusin", blur: "focusout"}, işlev (e, t) {var n = fonksiyon (e) {w.event.benzetmek (t, e.target, w.event.fix (e))}; w.event.special [t] = {setup: function () {var r = this.ownerDocument || this, i = J.access (r, t); i || r.addEventListener (e, n,! 0), J.access (r, t, (i || 0) +1)}, teardown: function () {var r = this .ownerDocument || bu, i = J.access (r, t) -1 i J.access (r, t, i) :( r.removeEventListener (yani, n = 0,!), J.remove (r? , t))}}}); var Ct = e.location, Et = Date.now (), kt = / \? /; w.parseXML = function (t) {var n; if (! t || " string "! = typeof t) return null; deneyin {n = (yeni e.DOMParser) .parseFromString (t," text / xml ")} catch (e) {n = geçersiz 0} return n &&! n.getElementsByTagName (" ayrıştırıcı "). uzunluk || w.error (" Geçersiz XML: "+ t), n}; var St = / \ [\] $ /, Dt = / \ r? \ n / g, Nt = / ^ ( ?: gönder | button | image | reset | file) $ / i, At = / ^ (?: input | select | textarea | keygen) / i; function jt (e, t, n, r) {var i; (Array.isArray (t)) w.each (t, fonksiyon (t, i) {n || St.test (e) r (e, i): jt (e + "[" + ("nesne "== typeof i & null! = i? t:" ") +"] ", i, n, r)}); yoksa eğer (n ||" nesne "! == x (t)) r (e, t); (i in t) dışındakiler jt (e + "[" + i + "]", t [i], n, r)} w.param = fonksiyon (e, t) {var n, r = [] , i = fonksiyon (e, t) {var n = g (t)? t (): t; r [r.lm] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? "": n)}; if (Array.isArray (e) || e.jquery &&! w.isPlainObject (e)) w.each (e, function () {i (this.name, this.value)}); (e in) jt (n, e [n], t, i); dönüş r.join ("&")}, w.fn.extend ({serialize: function () {return w.param (bu). serializeArray ())}, serializeArray: function () {return this.map (function () {var e = w.prop (this, "elements"); return e? w.makeArray (e): this}). (function () {var e = this.type; this.name döndürün &&! w (this) .is (": disabled") && At.test (this.nodeName) &&! Nt.test (e) && (this.checked ||! pe.test (e))}). map (işlev (e, t) {var n = w (this) .val (); return null == n? null : Array.isArray (n) w.map (n, fonksiyon (e) {dönüş {adı: t.name, değeri: e.replace (Dt "\ r \ n")}}): {adı: tR .name, değer: n.replace (Dt, "\ r \ n")}}). get ()}}); var qt = /% 20 / g, Lt = / #. * $ /, Ht = / ([? &]) _ = [^ &] * /, Ot = / ^ (. *?): [\ T] * ([^ \ r \ n] *) $ / gm, Pt = / ^ (? : yaklaşık | app | app-storage | + - uzantısı | dosya | res | widget):. $ /, Mt = / ^ (?: GET | BAŞLIK) $ /, Rt = / ^ \ / \ // O = {}, Wt = {}, $ t = "* /". Concat ("*"), Bt = r.createElement ("a"); Bt.href = Ct.href; işlevi Ft (e) {return işlevi (t, n) {"string"! = t&& (n = t, t = "*"); var r, i = 0, o = t.toLowerCase (). match (M) || []; (g (n)) (r = o [i ++]) "+" === r [0]? (r = r.slice (1) || "*", (e [d] = e [r ise ] || []). vites değiştirme (n)) :( e [r] = e [r] || []) .tuş (n)}} işlevi _t (e, t, n, r) {var i = {} o = e === Wt;işlev a (s) {var u; dönüş i [s] =! 0, w.each (e [s] || [], işlev (e, s) {var l = s (t, n, r); Döndür "string"! = typeof l || o || i [l]? o?! (u = l): void 0: (t.dataTypes.unshift (l), a (l) ,! 1)}) , u}, bir (t.dataTypes [0]) ||! i ["*"] & & a ("*")} işlevini döndürür zt (e, t) {var n, r, i = w.ajaxSettings.flatOptions | | {}; (n in t) için geçersiz 0! == t [n] && ((i [n]? e: r || (r = {})) [n] = t [n]); r && w.extend (! 0, e, r), e} işlevi Xt (e, t, n) {var r, i, o, a, s = e.contents, u = e.dataTypes; iken ("*" === u [0]) u.shift (), void 0 === r && (r = e.mimeType || t.getResponseHeader ("Content-Type")); (r) için (i) if (s [i] && s [i] .test (r)) {u.unshift (i); break} if (n [u] 0) o = u [0]; else {için (i in n) {if (! u [0] || e.converters [i + "" + u [0]]) {o = i; break} a || (a = i)} o = o || a} eğer (o ) return o! == u [0] && u.çift (o), n [o]} işlevi Ut (e, t, n, r) {var i, o, a, s, u, l = {}, c = e.dataTypes.dilim (); (c [1]) için (a. e.birimde) l [a.toLowerCase ()] = e. için [a]; a =; o = c.shift (); .responseFields [o] && (N- [e.responseFields [o]] = t) ,! u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)) u = o, o = c.shift () ) eğer ("*" === o) o = u; yoksa eğer ("*"! == u && u! == o) {if (! (a = l [u + "" + o] || l [" * "+ o])) (in l) için (((s = i.split (" ")) [1] === o && (a = l [u +" "+ s [0]] || l ["*" + s [0]])) {! 0 === a? a = l [i] :! 0! == l [i] && (o = s [0], c. [1])); break} eğer (! 0! == a) eğer (a && e ["atar"]) t = a (t); yoksa {t = a (t)} yakala (e) {return { state: "parsererror", hata: a? e: "" + u + "den" + o}}} ye dönüşme yok {state: "success", veri: t}} w.extend ({active: 0, lastModified : {}, etag: {}, ajaxSettings: {url: Ct.href yazın: Pt: isLocal "GET".test (Ct.protocol), global:! 0, processData:! 0, async:! 0, contentType: "uygulama / x-www-form-urlencoded; charset = UTF-8", kabul eder: {"*": $ t, metin: "metin / düz", html: "metin / html", xml: "uygulama / xml, metin / xml", json: "uygulama / json, metin / javascript"}, içerik: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: {xml: "responseXML", metin: "responseText", json: "responseJSON"}, dönüştürücüler: {"* text ": String," text html ":! 0," text json ": JSON.parse," text xml ": w.parseXML}, flatOptions: {url:! 0, bağlam:! 0}}, ajaxSetup: function ( e, t) {return t z zt (zt (e, w.ajaxSettings), t): zt (w.ajaxSettings, e)}, ajaxPrefilter: Ft (O), ajaxTransport: Ft (Wt), ajax: işlevi ( t, n) {"nesne" == t && (n = t, t = boşluk 0), n = n || {}; var i, o, a, s, u, l, c, f, p, d, H = a.ajaxSetup ({}, n) (g) 'a, g = h.context || H'dir, Y = h.context && (g.nodeType || g.jquery): w.event, h = w.Deferred (), m = w.Callbacks ("bir kez bellek"), x = h.statusCode || {}, b = {}, T = {}, C = "iptal edildi", E = {readyState: 0, getResponseHeader: function (e ) {var t; eğer (c) {eğer (! s) {s = {}; süre (t = Ot.exec (a)) s [t [1] .toLowerCase ()] = t [2]} t = s [e.toLowerCase ()]} return null == t? null: t}, getAllResponseHeaders: function () {return c? a: null}, setRequestHeader: function (e, t) {return null == c && ( e = T [e.toLowerCase ()] = T [e.toLowerCase ()] || e, b [e] = t), bu}, overrideMimeType: function (e) {return null == c && (h.mimeType = e), bu}, statusCode: function (e) {var t; eğer (e) eğer (c) E.always (e [E.status]); başka için (e in t) x [t] = [ x [t], e [t]]; bunu döndürün}, abort: function (e) {var t = e || C; i && i.abort (t), k (0, t), bu}} döndürün; (v.promise (E), h.url = ((t || h.url || Ct.href) + ""). (R,, Ct.protocol yerine +"//"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||"*").toLowerCase().match(M ) || [ ""], boş == h.crossDomain) {l = r.createElement ( "a"); deneyin {l.href = h.url, l.href = l.href, h.crossDomain = Bt .protocol + "//" + Bt.host! = l.protocol + "//" + l.host} catch (e) {h.crossDomain =! 0}} if (h.data && h.processData && "string"! = typeof h.data && (h.data = w.param (h.data, h.traditional)), _ t (Bu, h, n, E), c) E döndürür; (f = w.event && h.global) && 0 == w.active ++ && w.event.trigger ( "ajaxStart"), h.type = h.type.toUpperCase (), h.hasContent =! Mt.test (h.type), o = h.url.replace ( LT, ""), h.hasContent? h.data && h.processData && 0 === (h.contentType || ""). indexOf ( "uygulama / x-www-form-urlencoded") && (h.data = h. data.replace (qt, "+")):(d = h.url.slice (saniye), h.data && (h.processData || "string" == h.data) - & ((+ (kt.test (o)? "&": ")" ? ") + h.data, h.data silin) ​​,! 1 === h.cache && (o = o.replace (Ht," $ 1 "), d = (kt.test (o)?" & ": "?") + "_ =" + Et +++ d) h.url = o + d), h.ifModified && (w.lastModified [o] && E.setRequestHeader ( "değişiklikte-yana", w. lastModified [o]), w.etag [o] && E.setRequestHeader ( "If-None-Match", w.etag [o])), (h.data && h.hasContent &&! 1! == h.contentType || n .contentType) && E.setRequestHeader ( "İçerik-tipi", h.contentType), E.setRequestHeader ( "Kabul Et", h.dataTypes [0] && h.accepts [h.dataTypes [0]]? h.accepts [h. dataTypes [0]] + ("*"! == h.dataTypes [0]? "," + $ t + "; q = 0.01": ""): h.accepts ["* "]); (h.başında p) E.setRequestHeader (p, h.başlığı [p]); eğer (h.beforeSend && (! 1 === h.beforeSall.call (g, E, h) || c)) E.abort () döndürürse, (C = "iptal", m.add (h.complete), E.done (h.success), E.fail (h.error), i = _t (Wt, h, n, E)) {eğer (E.readyState = 1, f && y.trigger ("ajaxSend", [E, h]), c) E döndürür; h.async && h.timeout> 0 && (u = e .setTimeout (function () {E.abort ("timeout")}, h.timeout)); deneyin {c =! 1, i.send (b, k)} catch (e) {eğer (c) e ; k (-1, e)}} else k (-1, "Nakil Yok"); işlev k (t, n, r, s) {var 1, p, d, b, T, C = n; c || (c =! 0, u && e.clearTimeout (u), i = geçersiz 0, a = s || "", E.readyState = t> 0? 4: 0, l = t> = 200 && t <300 || 304 === t, r && (b = Xt (h, e, r)), b = Ut (s, b, e, l), l? (h.ifModified && ((T = E.getResponseHeader ( "adı geçen son Değiştirilmiş "(w.lastModified [o] = T) &&)), (T = E.getResponseHeader (" etag")) && (w.etag [o] = T)), 204 === t || "kafa" === h.type C = "nocontent": 304 === tC = "NotModified": (C = b.state, p = b.data, I =! (d = b.error))) :( D = C,! t && Cı || (C = "hata" t <0 && (t = 0) )), E.status = t, E.statusText = (n || C) + "", l v.resolveWith (g, [p, C, E]): v.rejectWith (g, [E, Cı , d]), E.statusCode (x), x = geçersiz 0, f && y.trigger (l? "ajaxSuccess": "ajaxError", [E, h, l? p: d]), m.fireWith (g, [E, C]), f && (y.trigger ("ajaxComplete", [E, h]), - w.active || w.event.trigger ("ajaxStop")))} return E}, getJSON: function (e, t, n) {return w.get (e, t, n, "json")}, getScript: function (e, t) {return w.get (e, geçersiz 0, t, "script" )}}), w.each (["get", "post"], işlev (e, t) {w [t] = işlev (e, n, r, i) {return g (n) && (i = i || r, r = n, n = boş 0), w.ajax (w.extend ({url: e, tür: t, dataType: i,veri: n, başarı: r}, w.isPlainObject (e) && e))}}), w._evalUrl = function (e) {return w.ajax ({url: e, türü: "GET", dataType: " script ", cache:! 0, async:! 1, global:! 1," throws ":! 0})}, w.fn.extend ({wrapAll: function (e) {var t; return [0] && (g (e) && (e = e.call (bu [0])), t = w (e, bu [0] .ownerDocument) .eq (0) .clone (! 0), bu [0] .parentNode && t.insertBefore (this [0]), t.map (function () {var e = this; while (e.firstElementChild) e = e.firstElementChild; return e}). append (this)), this}, wrapInner: function (e) {return g (e)? this.each (function (t) {w (bu) .wrapInner (e.call (this, t))}): this.each (function () {var t = w (bu), n = t.contents (); n.length? n.wrapAll (e): t.append (e)})}, sarma: function (e) {var t = g (e) ; return this.each (function (n) {w (this) .wrapAll (t? e.call (this, n): e)})}, unwrap: function (e) {return this.parent (e). vücüt değil").Bu}}), w.expr.pseudos.hidden = fonksiyonu (e) {dönmek her ({(bu) .replaceWith (this.childNodes w)} fonksiyonu ())! W.expr.pseudos.visible (e) } w.expr.pseudos.visible = fonksiyonu (e) {dönüş !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). uzunluk)}, w.ajaxSettings.xhr = fonksiyonu () {deneyin {yeni e.XMLHttpRequest döndürün} catch (e) {}}; var Vt = {0: 200,1223: 204}, Gt = w.ajaxSettings.xhr (); h.cors = !! Gt && "withCredentials" ile Gt , h.ajax = Gt = !! Gt, w.ajaxTransport (function (t) {var n, r; eğer (h.cors || Gt &&! t.crossDomain) return {send: function (i, o) {var a, s = t.xhr (); eğer (s.open (t.type, t.url, t.async, t.username, t.password), t.xhrFields) (a, t.xhrFields içinde) s [a] o = t.xhrFields [a]; t.mimeType && s.overrideMimeType && s.overrideMimeType (t.mimeType), t.crossDomain || i [ "X-Talep-ile"] || (i [ "X-İstenen-ile "] =" XMLHttpRequest "); (a in i) için.setRequestHeader (a, i [a]); n = function (e) {return işlevi () {n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e? s.abort (): "hata" === e? "sayı"! = typeof s.status? o (0, "error"): o (s.status, s.statusText ): o (Vt [s.status] || s.status, s.statusText, "metin"! == (s.responseType || "metin") || "string"! = = s.responseText? {binary : s.response}: {metni: s.responseText} s.getAllResponseHeaders ()))}} s.onload = n () r = s.onerror = s.ontimeout = n ( "hata") void ! 0 == s.onabort s.onabort = r: s.onreadystatechange = fonksiyonu (): {4 === s.readyState && e.setTimeout (fonksiyonu () {n && r ()})}, n = n '( "iptal" ); deneyin {s.send (t.hasContent && t.data || null)} catch (e) {eğer (n) atma e}}, iptal et: function () {n && n ()}}}), w.ajaxPrefilter ( fonksiyonu (e) {e.crossDomain && (örn.content.script =! 1)}), w.ajaxSetup ({kabul: {script: "metin / javascript, uygulama / javascript, uygulama / ecmascript, uygulama / x-ecmascript"}, içerik: {script: / \ b ( ?: java | ecma) betiği \ b /}, dönüştürücüler: {"text script": function (e) {return w.globalEval (e), e}}}), w.ajaxPrefilter ("script", function (e ) {void 0 === e.cache && (e.cache =! 1), e.crossDomain && (e.type = "GET")}), w.ajaxTransport ("script", fonksiyon (e) {eğer (e) .crossDomain) {var t, n; return {send: function (i, o) {t = w ("<script>") .prop ({charset: e.scriptCharset, src: e.url}). "yükleme hatası", n = işlev (e) {t.remove (), n = null, e && o ("hata" === e.type? 404: 200, e.type)}), r.head.appendChild (t [0])}, iptal: function () {n && n ()}}}}); var Yt = [], Qt = / (=) \? (? = & | $) | \? \? / ; w.ajaxSetup ({jsonp: jsonpCallback "geri":function () {var e = Yt.pop () || w.expando + "_" + Et ++; şunu döndür [e] =! 0, e}}), w.ajaxPrefilter ("json jsonp", function (t, n, r) {var i, o, a, s =! 1! == t.jsonp && (Qt.test (t.url)? "url": "string" == typ.tr & & 0 === (t .contentType || "") indexOf (. "uygulama / x-www-form-urlencoded") && Qt.test (t.data) && "veri"); eğer (ler || "jsonp" === t.dataTypes [0]) dönüş i = t.jsonpCallback = g (t.jsonpCallback)? T.jsonpCallback (): t.jsonpCallback, s? T [s] = t [s]. Yerine (Qt, "$ 1" + i) :! 1! == t.jsonp && (t.url + = (kt.test (t.url)? "&": "?") + T.jsonp + "=" + i), t.converters ["script json "] = function () {bir || w.error (i +" çağrılmadı "), bir [0]}, t.dataTypes [0] =" json ", o = e [i], e [i ] = function () {a = bağımsız değişkenler}, r.always (function () {void 0 === o? w (e).removeProp: (i) e [i] = O, t [i] && (t.jsonpCallback = n.jsonpCallback, Yt.push (i)), bir && gr (O) && o (a [0]), a = o = void 0}), "script"}), h.createHTMLDocument = function () {var e = r.implementation.createHTMLDocument (""). body; return e.innerHTML = "<form> </form> <form> </form> ", 2 === e.childNodes.length} (), w.parseHTML = işlevi (e, t, n) {if (" string "! = e) yazın [];" boolean "= = t&& (n = t, t =! 1); var i, o, a; return t || (h.createHTMLDocument? ((i = (t = r.implementation.createHTMLDocument ("")))) createElement ( . "temel")) href = r.location.href, t.head.appendChild (i)): tR = r) o = A.exec (e), bir n = && [], o [t!?. createElement (o [1])] :( o = xe ([e], t, a) bir && a.length && ağırlık (a) '.Gergi (), w.merge ([], o.childNodes))} w. fn.load = fonksiyon (e, t, n) {var r, i, o, a = bu, s = e.indexOf ("");s> -1 && (r = vt (e.slice (s)), e = e.slice (0, s)), g (t)? (n = t, t = boşluk 0): t && "nesne" döndür == t && (i = "POST"), a.length> 0 && w.ajax ({url: e, şunu yazın: i || "GET", dataType: "html", veri: t}). done (işlev ( e) {o = argümanlar, a.html (r (w "<div>"?) ekleme (w.parseHTML (e)) bulmak (r). e.)}.) her zaman (n && fonksiyonu (yani, t); {a.each (fonksiyonu () {n.apply (bu, o || [e.responseText, t, e])})}), bu} w.each ([ "ajaxStart", "ajaxStop"," ajaxComplete "," ajaxError "," ajaxSuccess "," ajaxSend "], işlevi (e, t) {w.fn [t] = işlev (e) {return this.on (t, e)}}), w. expr.pseudos.animated = function (e) {return w.grep (w.timers, function (t) {return e === t.elem}). length}, w.offset = {setOffset: function (e, t, n) {var r, i, o, a, s, u, l, c = w.css (e, "konum"), f = w (e), p = {}; "statik"=== c && (e.style.position = "nispi")) (, s = f.offset, o = w.css (yani, "üst"), u = w.css (yani, "sol"), (l = ( "mutlak" === c || "sabit" === c) && (o + u) .indexOf ( "otomatik")> - 1)? (a = (r = f.position () ) .top, i = r.left) :( a = parseFloat (o) || 0, i = parseFloat (u) || 0), g (t) && (t = t.call (yani, n, w .extend ({}, s))), sıfır! = t.top && (p.top = t.top-s.top + a), boş! = t.left && (p.left = t.left-s. left + i), t? t.using.call (e, p) 'de "kullanma": f.css (p)}}, w.fn.extend ({offset: function (e) {if (arguments.length ) return void 0 === e? this: this.each (function (t) {w.offset.setOffset (this, e, t)}); var t, n, r = this [0]; if (r ) r.getClientRects (). uzunluk döndürür mü (t = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, {top: t.top + n.pageYOffset, sol: t.left + n.pageXOffset}): {top: 0, sol: 0}}, position: function () {eğer (bu [0]) {var e, t, n, r = bu [0], i = {top: 0,Sol: 0} ( "sabit" === w.css (r, "pozisyonu")) göre t = r.getBoundingClientRect (); başka {t = this.offset (), n = r.ownerDocument e = r.offsetParent || n.documentElement; ise (e && (e === n.body || e === n.documentElement) && "statik" === w.css (yani, "pozisyonu")) e = e.parentNode;!.! e && e == r && 1 === e.nodeType && ((i = w (e) .offset ()) üst + = w.css (yani, "borderTopWidth", 0), i.left + w = css (yani, "borderLeftWidth", 0!))} dönüş {En: t.top-i.top-w.css (r, "marginTop", 0), sol: t.left-i.left- w.css (r, "marginLeft",! 0)}}}, offsetParent: function () {return this.map (function () {var e = this.offsetParent; iken (e && "statik" === w. css (e, "position")) e = e.offsetParent; return e || be})}}), w.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, işlev (e, t) {var n = "pageYOffset "=== t; w.fn [e] = function (r) {return z (bu, function (e, r, i) {var o; eğer (y (e)? o = e: 9 == = e.nodeType && (o = e.defaultView), void 0 === i) o o o [t] döndürür: e [r]; o? o.scrollTo (n? o.pageXOffset: i, n? i: o.pageYOffset): ([ "üst", "sol"] e [r] = ı}, e, r, arguments.length)}}), w.each, fonksiyon (örneğin, t) {w.cssHooks [ t] = _ e (h.pixelPosition, işlev (e, n) {eğer (n), n = Fe (e, t), We.test (n)? w (e) .position () [t] + " piksel ": n})}), w.each ({Yükseklik:" yükseklik", En: "genişlik"}, fonksiyon (örn, t) {w.each ({doldurma "iç" + e, içerik: tR , "": "outer" + e}, işlev (n, r) {w.fn [r] = işlev (i, o) {var a = arguments.length && (n || "boolean"! = i) , s = n || (! 0 === i ||! 0 === o? "marj": "sınır"); dönüş z (bu, fonksiyon (t, n, i) {var o; dönüş y (t) 0 === r.indexOf ( "dış") t [ "iç" + e]:? t.document.documentElement [ "müşteri" + e]: 9 === t.nodeType (o = t.documentElement, Math.max (t.body [ "kaydırma" + e], [ "kaydırma" + e], t O?. gövde ["ofset" + e], o ["ofset" + e], o ["müşteri" + e])): geçersiz 0 === i? w.css (t, n, s): w.style (t, n, i, s)}, t, a? i: void 0, a)}})}), w.each ("odak odağını odakla yeniden boyutlandır, kaydırma tıkla dblclick mousown mouse mousemove mouseover mouseout mouseenter keydown keypress keyup bağlam menüsü ".split (" "), işlev (e, t) {w.fn [t] = işlev (e, n) {return arguments.length> 0? this.on (t, null, e , n): this.trigger (t)}}), w.fn.extend ({hover: function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}}), w .fn.extend ({bind: function (e, t, n) {geri this.on (e, null, t, n)}, unbind: function (e, t) {geri this.off (e, null, t)}, temsilci: function (e, t, n, r) {return this.on (t, e, n, r)}, temsilci:işlevi (e, t, n) {return 1 === arguments.length? this.off (e, "**"): this.off (t, e || "**", n)}}), w.proxy = fonksiyon (e, t) {var n, r, i; if ("string" == t && (n = e [t], t = e, e = n), g (e)) dönüş r = o.call (argümanlar, 2), i = function () {return e.apply (t || this, r.concat (o.call (argümanlar))))}, i.guid = e.guid = e .guid || w.guid ++ ı}, w.holdReady = fonksiyonu (e) {e w.readyWait ++: (! 0) w.ready} w.isArray = Array.isArray, w.parseJSON = JSON.parse , w.nodeName = N, w.isFunction = g, w.isWindow = y, w.camelCase = G, w.type = x, w.now = Date.now, w.isNumeric = işlev (e) {var t = w.type (e); return ("sayı" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "function" == typeof define && define.amd && define ( "jquery", [], function () {return w}); var Jt = e.jQuery, Kt = e. $; return w.noConflict = function (t) {return e. $ === w && (e. $ = KT) t && e.jQuery === ağırlık && (e.jQuery = Jt) w w}, t || (e.jQuery = e $ = W).});